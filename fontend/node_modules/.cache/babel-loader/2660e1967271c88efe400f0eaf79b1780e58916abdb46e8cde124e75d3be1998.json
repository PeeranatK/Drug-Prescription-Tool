{"ast":null,"code":"import { useCallback, useRef } from 'react';\nimport addStyle from 'dom-lib/addStyle';\nimport { SCROLLBAR_WIDTH } from '../constants';\nimport toggleClass from './toggleClass';\nimport useUpdateEffect from './useUpdateEffect';\nimport isSupportTouchEvent from './isSupportTouchEvent';\nimport defer from './defer';\n\n/**\n * Update the position of the table according to the scrolling information of the table.\n * @param props\n * @returns\n */\nvar usePosition = function usePosition(props) {\n  var data = props.data,\n    height = props.height,\n    tableWidth = props.tableWidth,\n    tableRef = props.tableRef,\n    prefix = props.prefix,\n    translateDOMPositionXY = props.translateDOMPositionXY,\n    wheelWrapperRef = props.wheelWrapperRef,\n    headerWrapperRef = props.headerWrapperRef,\n    affixHeaderWrapperRef = props.affixHeaderWrapperRef,\n    tableHeaderRef = props.tableHeaderRef,\n    scrollX = props.scrollX,\n    scrollY = props.scrollY,\n    contentWidth = props.contentWidth,\n    shouldFixedColumn = props.shouldFixedColumn;\n  var duration = useRef(0);\n  var bezier = useRef('linear');\n  var getScrollCellGroups = useCallback(function () {\n    var _tableRef$current;\n    return ((_tableRef$current = tableRef.current) === null || _tableRef$current === void 0 ? void 0 : _tableRef$current.querySelectorAll(\".\" + prefix('cell-group-scroll'))) || [];\n  }, [prefix, tableRef]);\n  var getFixedLeftCellGroups = useCallback(function () {\n    var _tableRef$current2;\n    return (_tableRef$current2 = tableRef.current) === null || _tableRef$current2 === void 0 ? void 0 : _tableRef$current2.querySelectorAll(\".\" + prefix('cell-group-fixed-left'));\n  }, [prefix, tableRef]);\n  var getFixedRightCellGroups = useCallback(function () {\n    var _tableRef$current3;\n    return (_tableRef$current3 = tableRef.current) === null || _tableRef$current3 === void 0 ? void 0 : _tableRef$current3.querySelectorAll(\".\" + prefix('cell-group-fixed-right'));\n  }, [prefix, tableRef]);\n  var updateWheelElementPosition = useCallback(function (fixedCell) {\n    if (wheelWrapperRef !== null && wheelWrapperRef !== void 0 && wheelWrapperRef.current) {\n      // The animation when the mobile device touches and scrolls.\n      var wheelStyle = isSupportTouchEvent() ? {\n        'transition-duration': duration.current + \"ms\",\n        'transition-timing-function': bezier.current\n      } : {};\n      translateDOMPositionXY.current(wheelStyle, fixedCell ? 0 : scrollX.current, scrollY.current);\n      addStyle(wheelWrapperRef.current, wheelStyle);\n    }\n  }, [scrollX, scrollY, translateDOMPositionXY, wheelWrapperRef]);\n  var updatePositionByFixedCell = useCallback(function () {\n    var wheelGroupStyle = {};\n    var scrollGroups = getScrollCellGroups();\n    var fixedLeftGroups = getFixedLeftCellGroups();\n    var fixedRightGroups = getFixedRightCellGroups();\n    translateDOMPositionXY.current(wheelGroupStyle, scrollX.current, 0);\n    var scrollArrayGroups = Array.from(scrollGroups);\n    for (var i = 0; i < scrollArrayGroups.length; i++) {\n      var group = scrollArrayGroups[i];\n      addStyle(group, wheelGroupStyle);\n    }\n    updateWheelElementPosition(true);\n    var leftShadowClassName = prefix('cell-group-left-shadow');\n    var rightShadowClassName = prefix('cell-group-right-shadow');\n    var showLeftShadow = scrollX.current < 0;\n    var showRightShadow = tableWidth.current - contentWidth.current - SCROLLBAR_WIDTH !== scrollX.current;\n    toggleClass(fixedLeftGroups, leftShadowClassName, showLeftShadow);\n    toggleClass(fixedRightGroups, rightShadowClassName, showRightShadow);\n  }, [contentWidth, getFixedLeftCellGroups, getFixedRightCellGroups, getScrollCellGroups, updateWheelElementPosition, prefix, scrollX, tableWidth, translateDOMPositionXY]);\n  /**\n   * Update the position of the table according to the scrolling information of the table.\n   * @param nextDuration CSS transition-duration\n   * @param nextBezier CSS transition-timing-function\n   */\n\n  var updatePosition = useCallback(function (nextDuration, nextBezier) {\n    if (nextDuration) {\n      duration.current = nextDuration;\n    }\n    if (nextBezier) {\n      bezier.current = nextBezier;\n    } // When there are fixed columns.\n\n    if (shouldFixedColumn) {\n      updatePositionByFixedCell();\n    } else {\n      var _affixHeaderElement$h;\n      var headerStyle = {};\n      translateDOMPositionXY.current(headerStyle, scrollX.current, 0);\n      var headerElement = headerWrapperRef === null || headerWrapperRef === void 0 ? void 0 : headerWrapperRef.current;\n      var affixHeaderElement = affixHeaderWrapperRef === null || affixHeaderWrapperRef === void 0 ? void 0 : affixHeaderWrapperRef.current;\n      updateWheelElementPosition();\n      headerElement && addStyle(headerElement, headerStyle);\n      if (affixHeaderElement !== null && affixHeaderElement !== void 0 && (_affixHeaderElement$h = affixHeaderElement.hasChildNodes) !== null && _affixHeaderElement$h !== void 0 && _affixHeaderElement$h.call(affixHeaderElement)) {\n        addStyle(affixHeaderElement === null || affixHeaderElement === void 0 ? void 0 : affixHeaderElement.firstChild, headerStyle);\n      }\n    }\n    if (tableHeaderRef !== null && tableHeaderRef !== void 0 && tableHeaderRef.current) {\n      toggleClass(tableHeaderRef.current, prefix('cell-group-shadow'), scrollY.current < 0);\n    }\n  }, [affixHeaderWrapperRef, updateWheelElementPosition, headerWrapperRef, prefix, scrollX, scrollY, shouldFixedColumn, tableHeaderRef, translateDOMPositionXY, updatePositionByFixedCell]);\n  useUpdateEffect(function () {\n    if (scrollY.current !== 0) {\n      updatePosition();\n    }\n  }, [height, data]);\n  return {\n    forceUpdatePosition: updatePosition,\n    deferUpdatePosition: function deferUpdatePosition(nextDuration, nextBezier) {\n      defer(function () {\n        updatePosition(nextDuration, nextBezier);\n      });\n    }\n  };\n};\nexport default usePosition;","map":{"version":3,"names":["useCallback","useRef","addStyle","SCROLLBAR_WIDTH","toggleClass","useUpdateEffect","isSupportTouchEvent","defer","usePosition","props","data","height","tableWidth","tableRef","prefix","translateDOMPositionXY","wheelWrapperRef","headerWrapperRef","affixHeaderWrapperRef","tableHeaderRef","scrollX","scrollY","contentWidth","shouldFixedColumn","duration","bezier","getScrollCellGroups","_tableRef$current","current","querySelectorAll","getFixedLeftCellGroups","_tableRef$current2","getFixedRightCellGroups","_tableRef$current3","updateWheelElementPosition","fixedCell","wheelStyle","updatePositionByFixedCell","wheelGroupStyle","scrollGroups","fixedLeftGroups","fixedRightGroups","scrollArrayGroups","Array","from","i","length","group","leftShadowClassName","rightShadowClassName","showLeftShadow","showRightShadow","updatePosition","nextDuration","nextBezier","_affixHeaderElement$h","headerStyle","headerElement","affixHeaderElement","hasChildNodes","call","firstChild","forceUpdatePosition","deferUpdatePosition"],"sources":["/Users/peeranat/Desktop/Project copy 2/fontend/node_modules/rsuite-table/es/utils/usePosition.js"],"sourcesContent":["import { useCallback, useRef } from 'react';\nimport addStyle from 'dom-lib/addStyle';\nimport { SCROLLBAR_WIDTH } from '../constants';\nimport toggleClass from './toggleClass';\nimport useUpdateEffect from './useUpdateEffect';\nimport isSupportTouchEvent from './isSupportTouchEvent';\nimport defer from './defer';\n\n/**\n * Update the position of the table according to the scrolling information of the table.\n * @param props\n * @returns\n */\nvar usePosition = function usePosition(props) {\n  var data = props.data,\n      height = props.height,\n      tableWidth = props.tableWidth,\n      tableRef = props.tableRef,\n      prefix = props.prefix,\n      translateDOMPositionXY = props.translateDOMPositionXY,\n      wheelWrapperRef = props.wheelWrapperRef,\n      headerWrapperRef = props.headerWrapperRef,\n      affixHeaderWrapperRef = props.affixHeaderWrapperRef,\n      tableHeaderRef = props.tableHeaderRef,\n      scrollX = props.scrollX,\n      scrollY = props.scrollY,\n      contentWidth = props.contentWidth,\n      shouldFixedColumn = props.shouldFixedColumn;\n  var duration = useRef(0);\n  var bezier = useRef('linear');\n  var getScrollCellGroups = useCallback(function () {\n    var _tableRef$current;\n\n    return ((_tableRef$current = tableRef.current) === null || _tableRef$current === void 0 ? void 0 : _tableRef$current.querySelectorAll(\".\" + prefix('cell-group-scroll'))) || [];\n  }, [prefix, tableRef]);\n  var getFixedLeftCellGroups = useCallback(function () {\n    var _tableRef$current2;\n\n    return (_tableRef$current2 = tableRef.current) === null || _tableRef$current2 === void 0 ? void 0 : _tableRef$current2.querySelectorAll(\".\" + prefix('cell-group-fixed-left'));\n  }, [prefix, tableRef]);\n  var getFixedRightCellGroups = useCallback(function () {\n    var _tableRef$current3;\n\n    return (_tableRef$current3 = tableRef.current) === null || _tableRef$current3 === void 0 ? void 0 : _tableRef$current3.querySelectorAll(\".\" + prefix('cell-group-fixed-right'));\n  }, [prefix, tableRef]);\n  var updateWheelElementPosition = useCallback(function (fixedCell) {\n    if (wheelWrapperRef !== null && wheelWrapperRef !== void 0 && wheelWrapperRef.current) {\n      // The animation when the mobile device touches and scrolls.\n      var wheelStyle = isSupportTouchEvent() ? {\n        'transition-duration': duration.current + \"ms\",\n        'transition-timing-function': bezier.current\n      } : {};\n      translateDOMPositionXY.current(wheelStyle, fixedCell ? 0 : scrollX.current, scrollY.current);\n      addStyle(wheelWrapperRef.current, wheelStyle);\n    }\n  }, [scrollX, scrollY, translateDOMPositionXY, wheelWrapperRef]);\n  var updatePositionByFixedCell = useCallback(function () {\n    var wheelGroupStyle = {};\n    var scrollGroups = getScrollCellGroups();\n    var fixedLeftGroups = getFixedLeftCellGroups();\n    var fixedRightGroups = getFixedRightCellGroups();\n    translateDOMPositionXY.current(wheelGroupStyle, scrollX.current, 0);\n    var scrollArrayGroups = Array.from(scrollGroups);\n\n    for (var i = 0; i < scrollArrayGroups.length; i++) {\n      var group = scrollArrayGroups[i];\n      addStyle(group, wheelGroupStyle);\n    }\n\n    updateWheelElementPosition(true);\n    var leftShadowClassName = prefix('cell-group-left-shadow');\n    var rightShadowClassName = prefix('cell-group-right-shadow');\n    var showLeftShadow = scrollX.current < 0;\n    var showRightShadow = tableWidth.current - contentWidth.current - SCROLLBAR_WIDTH !== scrollX.current;\n    toggleClass(fixedLeftGroups, leftShadowClassName, showLeftShadow);\n    toggleClass(fixedRightGroups, rightShadowClassName, showRightShadow);\n  }, [contentWidth, getFixedLeftCellGroups, getFixedRightCellGroups, getScrollCellGroups, updateWheelElementPosition, prefix, scrollX, tableWidth, translateDOMPositionXY]);\n  /**\n   * Update the position of the table according to the scrolling information of the table.\n   * @param nextDuration CSS transition-duration\n   * @param nextBezier CSS transition-timing-function\n   */\n\n  var updatePosition = useCallback(function (nextDuration, nextBezier) {\n    if (nextDuration) {\n      duration.current = nextDuration;\n    }\n\n    if (nextBezier) {\n      bezier.current = nextBezier;\n    } // When there are fixed columns.\n\n\n    if (shouldFixedColumn) {\n      updatePositionByFixedCell();\n    } else {\n      var _affixHeaderElement$h;\n\n      var headerStyle = {};\n      translateDOMPositionXY.current(headerStyle, scrollX.current, 0);\n      var headerElement = headerWrapperRef === null || headerWrapperRef === void 0 ? void 0 : headerWrapperRef.current;\n      var affixHeaderElement = affixHeaderWrapperRef === null || affixHeaderWrapperRef === void 0 ? void 0 : affixHeaderWrapperRef.current;\n      updateWheelElementPosition();\n      headerElement && addStyle(headerElement, headerStyle);\n\n      if (affixHeaderElement !== null && affixHeaderElement !== void 0 && (_affixHeaderElement$h = affixHeaderElement.hasChildNodes) !== null && _affixHeaderElement$h !== void 0 && _affixHeaderElement$h.call(affixHeaderElement)) {\n        addStyle(affixHeaderElement === null || affixHeaderElement === void 0 ? void 0 : affixHeaderElement.firstChild, headerStyle);\n      }\n    }\n\n    if (tableHeaderRef !== null && tableHeaderRef !== void 0 && tableHeaderRef.current) {\n      toggleClass(tableHeaderRef.current, prefix('cell-group-shadow'), scrollY.current < 0);\n    }\n  }, [affixHeaderWrapperRef, updateWheelElementPosition, headerWrapperRef, prefix, scrollX, scrollY, shouldFixedColumn, tableHeaderRef, translateDOMPositionXY, updatePositionByFixedCell]);\n  useUpdateEffect(function () {\n    if (scrollY.current !== 0) {\n      updatePosition();\n    }\n  }, [height, data]);\n  return {\n    forceUpdatePosition: updatePosition,\n    deferUpdatePosition: function deferUpdatePosition(nextDuration, nextBezier) {\n      defer(function () {\n        updatePosition(nextDuration, nextBezier);\n      });\n    }\n  };\n};\n\nexport default usePosition;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}