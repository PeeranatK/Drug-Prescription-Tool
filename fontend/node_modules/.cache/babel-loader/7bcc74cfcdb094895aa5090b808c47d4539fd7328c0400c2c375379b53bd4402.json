{"ast":null,"code":"/**\n * interactive elements should be skiped\n * */\nvar INTERACTIVE_ELEMENTS = ['A', 'BUTTON', 'INPUT', 'OPTION', 'TEXTAREA', 'SELECT'];\nexport function isContainInteractiveElement(targetNode) {\n  return INTERACTIVE_ELEMENTS.includes(targetNode.tagName) || targetNode.contentEditable === 'true';\n}\nexport function setInlineStyles(node, styles) {\n  if (node !== null && styles !== null) {\n    for (var _i = 0, _Object$entries = Object.entries(styles); _i < _Object$entries.length; _i++) {\n      var _Object$entries$_i = _Object$entries[_i],\n        key = _Object$entries$_i[0],\n        value = _Object$entries$_i[1];\n      node.style[key] = value;\n    }\n  }\n}\nexport function setTranslate3d(node, translate) {\n  setInlineStyles(node, {\n    transform: translate ? \"translate3d(\" + translate.x + \"px,\" + translate.y + \"px,0)\" : ''\n  });\n}\nexport function setTransitionDuration(node, duration) {\n  setInlineStyles(node, {\n    transitionDuration: duration ? duration + \"ms\" : ''\n  });\n}\n/**\n * find closest target node from source node\n * */\n\nexport function closestNode(sourceNode, judge) {\n  var currentNode = sourceNode;\n  while (currentNode) {\n    if (judge(currentNode)) {\n      return currentNode;\n    }\n    currentNode = currentNode.parentNode;\n  }\n  return null;\n}\nexport function getEdgeOffset(node, parent, offset) {\n  if (offset === void 0) {\n    offset = {\n      left: 0,\n      top: 0\n    };\n  }\n  if (!node || !parent) {\n    return {};\n  } // Get the actual offsetTop / offsetLeft value, no matter how deep the node is nested\n\n  var nodeOffset = {\n    left: (offset.left || 0) + node.offsetLeft,\n    top: (offset.top || 0) + node.offsetTop\n  };\n  if (node.parentNode === parent) {\n    return nodeOffset;\n  }\n  return getEdgeOffset(node.parentNode, parent, nodeOffset);\n}\nexport function getScrollingParent(el) {\n  return closestNode(el, function (el) {\n    var computedStyle = window.getComputedStyle(el);\n    var overflowRegex = /(auto|scroll)/;\n    var properties = ['overflow', 'overflowX', 'overflowY'];\n    return properties.some(function (property) {\n      return overflowRegex.test(computedStyle[property]);\n    });\n  });\n}","map":{"version":3,"names":["INTERACTIVE_ELEMENTS","isContainInteractiveElement","targetNode","includes","tagName","contentEditable","setInlineStyles","node","styles","_i","_Object$entries","Object","entries","length","_Object$entries$_i","key","value","style","setTranslate3d","translate","transform","x","y","setTransitionDuration","duration","transitionDuration","closestNode","sourceNode","judge","currentNode","parentNode","getEdgeOffset","parent","offset","left","top","nodeOffset","offsetLeft","offsetTop","getScrollingParent","el","computedStyle","window","getComputedStyle","overflowRegex","properties","some","property","test"],"sources":["/Users/peeranat/Desktop/Project/fontend/node_modules/rsuite/esm/List/helper/utils.js"],"sourcesContent":["/**\n * interactive elements should be skiped\n * */\nvar INTERACTIVE_ELEMENTS = ['A', 'BUTTON', 'INPUT', 'OPTION', 'TEXTAREA', 'SELECT'];\nexport function isContainInteractiveElement(targetNode) {\n  return INTERACTIVE_ELEMENTS.includes(targetNode.tagName) || targetNode.contentEditable === 'true';\n}\nexport function setInlineStyles(node, styles) {\n  if (node !== null && styles !== null) {\n    for (var _i = 0, _Object$entries = Object.entries(styles); _i < _Object$entries.length; _i++) {\n      var _Object$entries$_i = _Object$entries[_i],\n          key = _Object$entries$_i[0],\n          value = _Object$entries$_i[1];\n      node.style[key] = value;\n    }\n  }\n}\nexport function setTranslate3d(node, translate) {\n  setInlineStyles(node, {\n    transform: translate ? \"translate3d(\" + translate.x + \"px,\" + translate.y + \"px,0)\" : ''\n  });\n}\nexport function setTransitionDuration(node, duration) {\n  setInlineStyles(node, {\n    transitionDuration: duration ? duration + \"ms\" : ''\n  });\n}\n/**\n * find closest target node from source node\n * */\n\nexport function closestNode(sourceNode, judge) {\n  var currentNode = sourceNode;\n\n  while (currentNode) {\n    if (judge(currentNode)) {\n      return currentNode;\n    }\n\n    currentNode = currentNode.parentNode;\n  }\n\n  return null;\n}\nexport function getEdgeOffset(node, parent, offset) {\n  if (offset === void 0) {\n    offset = {\n      left: 0,\n      top: 0\n    };\n  }\n\n  if (!node || !parent) {\n    return {};\n  } // Get the actual offsetTop / offsetLeft value, no matter how deep the node is nested\n\n\n  var nodeOffset = {\n    left: (offset.left || 0) + node.offsetLeft,\n    top: (offset.top || 0) + node.offsetTop\n  };\n\n  if (node.parentNode === parent) {\n    return nodeOffset;\n  }\n\n  return getEdgeOffset(node.parentNode, parent, nodeOffset);\n}\nexport function getScrollingParent(el) {\n  return closestNode(el, function (el) {\n    var computedStyle = window.getComputedStyle(el);\n    var overflowRegex = /(auto|scroll)/;\n    var properties = ['overflow', 'overflowX', 'overflowY'];\n    return properties.some(function (property) {\n      return overflowRegex.test(computedStyle[property]);\n    });\n  });\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}