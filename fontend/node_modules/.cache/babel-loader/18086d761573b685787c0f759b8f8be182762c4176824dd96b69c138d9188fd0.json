{"ast":null,"code":"import { useState, useEffect, useCallback } from 'react';\nimport uniq from 'lodash/uniq';\nimport remove from 'lodash/remove';\nimport slice from 'lodash/slice';\nimport { flattenTree } from '../utils/treeUtils';\nimport { attachParent } from '../utils/attachParent';\n\n/**\n * Get all parents of a node\n * @param node\n */\nexport var getParents = function getParents(node) {\n  var parents = [];\n  if (!node.parent) {\n    return parents;\n  }\n  parents.push(node.parent);\n  parents = parents.concat(getParents(node.parent));\n  return parents;\n};\n/**\n * Check if any child nodes are selected.\n * @param node\n * @param value\n * @param itemKeys\n */\n\nexport var isSomeChildChecked = function isSomeChildChecked(node, value, itemKeys) {\n  var childrenKey = itemKeys.childrenKey,\n    valueKey = itemKeys.valueKey;\n  if (!node[childrenKey] || !value) {\n    return false;\n  }\n  return node[childrenKey].some(function (child) {\n    var _child$childrenKey;\n    if (value.some(function (n) {\n      return n === child[valueKey];\n    })) {\n      return true;\n    }\n    if ((_child$childrenKey = child[childrenKey]) !== null && _child$childrenKey !== void 0 && _child$childrenKey.length) {\n      return isSomeChildChecked(child, value, itemKeys);\n    }\n    return false;\n  });\n};\n/**\n * Check if the parent is selected.\n * @param node\n * @param value\n * @param itemKeys\n */\n\nexport var isSomeParentChecked = function isSomeParentChecked(node, value, itemKeys) {\n  var valueKey = itemKeys.valueKey;\n  if (!value) {\n    return false;\n  }\n  if (value.some(function (n) {\n    return n === node[valueKey];\n  })) {\n    return true;\n  }\n  if (node.parent) {\n    return isSomeParentChecked(node.parent, value, itemKeys);\n  }\n  return false;\n};\nexport var getOtherItemValuesByUnselectChild = function getOtherItemValuesByUnselectChild(itemNode, value, itemKeys) {\n  var valueKey = itemKeys.valueKey,\n    childrenKey = itemKeys.childrenKey;\n  var parentValues = [];\n  var itemValues = []; // Find the parent node of the current node by value\n\n  function findParent(item) {\n    parentValues.push(item[valueKey]);\n    if (value.some(function (v) {\n      return v === item[valueKey];\n    })) {\n      return item;\n    }\n    if (item.parent) {\n      var p = findParent(item.parent);\n      if (p) {\n        return p;\n      }\n    }\n    return null;\n  } // Get child nodes through parent node\n\n  function pushChildValue(item) {\n    if (!item[childrenKey]) {\n      return;\n    }\n    item[childrenKey].forEach(function (n) {\n      // Determine whether it is a direct parent\n      if (parentValues.some(function (v) {\n        return v === n[valueKey];\n      }) && n[childrenKey]) {\n        pushChildValue(n);\n      } else if (n[valueKey] !== itemNode[valueKey]) {\n        itemValues.push(n[valueKey]);\n      }\n    });\n  }\n  var parent = findParent(itemNode);\n  if (!parent) {\n    return [];\n  }\n  pushChildValue(parent);\n  return itemValues;\n};\n/**\n * Remove the values of all children.\n */\n\nexport var removeAllChildrenValue = function removeAllChildrenValue(value, item, itemKeys) {\n  var valueKey = itemKeys.valueKey,\n    childrenKey = itemKeys.childrenKey;\n  var removedValue = [];\n  if (!item[childrenKey]) {\n    return;\n  }\n  item[childrenKey].forEach(function (n) {\n    removedValue = removedValue.concat(remove(value, function (v) {\n      return v === n[valueKey];\n    }));\n    if (n[childrenKey]) {\n      removeAllChildrenValue(value, n, itemKeys);\n    }\n  });\n  return removedValue;\n};\n/**\n * A hook to flatten tree structure data\n * @param data\n */\n\nexport function useFlattenData(data, itemKeys) {\n  var childrenKey = itemKeys.childrenKey;\n  var _useState = useState(flattenTree(data, itemKeys.childrenKey)),\n    flattenData = _useState[0],\n    setFlattenData = _useState[1];\n  var addFlattenData = useCallback(function (children, parent) {\n    var nodes = children.map(function (child) {\n      return attachParent(child, parent);\n    });\n    parent[childrenKey] = nodes;\n    setFlattenData([].concat(flattenData, nodes));\n  }, [childrenKey, flattenData]);\n  useEffect(function () {\n    setFlattenData(flattenTree(data, itemKeys.childrenKey));\n  }, [data, itemKeys.childrenKey]);\n  return {\n    addFlattenData: addFlattenData,\n    flattenData: flattenData\n  };\n}\n/**\n * A hook for column data\n * @param flattenData\n */\n\nexport function useColumnData(flattenData) {\n  // The columns displayed in the cascading panel.\n  var _useState2 = useState([flattenData.filter(function (item) {\n      return !item.parent;\n    })]),\n    columnData = _useState2[0],\n    setColumnData = _useState2[1];\n  /**\n   * Add a list of options to the cascading panel. Used for lazy loading options.\n   * @param column\n   * @param index The index of the current column.\n   */\n\n  function addColumn(column, index) {\n    setColumnData([].concat(slice(columnData, 0, index), [column]));\n  }\n  /**\n   * Remove subsequent columns of the specified column\n   * @param index\n   */\n\n  function removeColumnByIndex(index) {\n    setColumnData([].concat(slice(columnData, 0, index)));\n  }\n  function enforceUpdateColumnData(nextData) {\n    var nextFlattenData = flattenTree(nextData);\n    setColumnData([nextFlattenData.filter(function (item) {\n      return !item.parent;\n    })]);\n  }\n  return {\n    columnData: columnData,\n    addColumn: addColumn,\n    removeColumnByIndex: removeColumnByIndex,\n    setColumnData: setColumnData,\n    enforceUpdateColumnData: enforceUpdateColumnData\n  };\n}\n/**\n * A hook that converts the value into a cascading value\n * @param props\n * @param flattenData\n */\n\nexport function useCascadeValue(props, flattenData) {\n  var valueKey = props.valueKey,\n    childrenKey = props.childrenKey,\n    uncheckableItemValues = props.uncheckableItemValues,\n    cascade = props.cascade,\n    valueProp = props.value;\n  /**\n   * Get the values of all children\n   */\n\n  var getChildrenValue = useCallback(function (item) {\n    var values = [];\n    if (!item[childrenKey]) {\n      return values;\n    }\n    item[childrenKey].forEach(function (n) {\n      if (uncheckableItemValues && !uncheckableItemValues.some(function (v) {\n        return v === n[valueKey];\n      })) {\n        values.push(n[valueKey]);\n      }\n      values = values.concat(getChildrenValue(n));\n    });\n    return values;\n  }, [childrenKey, uncheckableItemValues, valueKey]);\n  var splitValue = useCallback(function (item, checked, value) {\n    var itemValue = item[valueKey];\n    var childrenValue = getChildrenValue(item);\n    var parents = getParents(item);\n    var nextValue = [].concat(value);\n    var removedValue = [];\n    if (checked) {\n      nextValue.push(itemValue); // Delete all values under the current node\n\n      removedValue = removedValue.concat(removeAllChildrenValue(nextValue, item, {\n        valueKey: valueKey,\n        childrenKey: childrenKey\n      }) || []); // Traverse all ancestor nodes of the current node\n      // Then determine whether all the child nodes of these nodes are selected, and then they themselves must be selected\n\n      var _loop = function _loop(i) {\n        // Whether the parent node can be selected\n        var isCheckableParent = !(uncheckableItemValues !== null && uncheckableItemValues !== void 0 && uncheckableItemValues.some(function (v) {\n          return v === parents[i][valueKey];\n        }));\n        if (isCheckableParent) {\n          var isCheckAll = parents[i][childrenKey] // Filter out options that are marked as not selectable\n          .filter(function (n) {\n            return !(uncheckableItemValues !== null && uncheckableItemValues !== void 0 && uncheckableItemValues.some(function (v) {\n              return v === n[valueKey];\n            }));\n          }) // Check if all nodes are selected\n          .every(function (n) {\n            return nextValue.some(function (v) {\n              return v === n[valueKey];\n            });\n          });\n          if (isCheckAll) {\n            // Add parent node value\n            nextValue.push(parents[i][valueKey]); // Delete all values under the parent node\n\n            removedValue = removedValue.concat(removeAllChildrenValue(nextValue, parents[i], {\n              valueKey: valueKey,\n              childrenKey: childrenKey\n            }) || []);\n          }\n        }\n      };\n      for (var i = 0; i < parents.length; i++) {\n        _loop(i);\n      }\n    } else {\n      var tempValue = childrenValue.concat(parents.map(function (item) {\n        return item[valueKey];\n      }));\n      nextValue = nextValue.concat(getOtherItemValuesByUnselectChild(item, nextValue, {\n        valueKey: valueKey,\n        childrenKey: childrenKey\n      })); // Delete related child and parent nodes\n\n      removedValue = remove(nextValue, function (v) {\n        // Delete yourself\n        if (v === itemValue) {\n          return true;\n        }\n        return tempValue.some(function (n) {\n          return n === v;\n        });\n      });\n    }\n    var uniqValue = uniq(nextValue);\n    var uniqRemovedValue = uniq(removedValue);\n    return {\n      value: uniqValue,\n      removedValue: uniqRemovedValue\n    };\n  }, [valueKey, childrenKey, uncheckableItemValues, getChildrenValue]);\n  var transformValue = useCallback(function (value) {\n    if (value === void 0) {\n      value = [];\n    }\n    if (!cascade) {\n      return value;\n    }\n    var tempRemovedValue = [];\n    var nextValue = [];\n    var _loop2 = function _loop2(i) {\n      // If the value in the current value is already in the deleted list, it will not be processed\n      if (tempRemovedValue.some(function (v) {\n        return v === value[i];\n      })) {\n        return \"continue\";\n      }\n      var item = flattenData.find(function (v) {\n        return v[valueKey] === value[i];\n      });\n      if (!item) {\n        return \"continue\";\n      }\n      var sv = splitValue(item, true, value);\n      tempRemovedValue = uniq(tempRemovedValue.concat(sv.removedValue)); // Get all relevant values\n\n      nextValue = uniq(nextValue.concat(sv.value));\n    };\n    for (var i = 0; i < value.length; i++) {\n      var _ret = _loop2(i);\n      if (_ret === \"continue\") continue;\n    } // Finally traverse all nextValue, and delete if its parent node is also nextValue\n\n    return nextValue.filter(function (v) {\n      var item = flattenData.find(function (n) {\n        return n[valueKey] === v;\n      });\n      if (item !== null && item !== void 0 && item.parent && nextValue.some(function (v) {\n        return v === item.parent && item.parent[valueKey];\n      })) {\n        return false;\n      }\n      return true;\n    });\n  }, [cascade, flattenData, splitValue, valueKey]);\n  var _useState3 = useState(transformValue(valueProp) || []),\n    value = _useState3[0],\n    setValue = _useState3[1];\n  useEffect(function () {\n    // Update value when valueProp is updated.\n    setValue(transformValue(valueProp) || []);\n  }, [transformValue, valueProp]);\n  return {\n    value: value,\n    setValue: setValue,\n    splitValue: splitValue\n  };\n}","map":{"version":3,"names":["useState","useEffect","useCallback","uniq","remove","slice","flattenTree","attachParent","getParents","node","parents","parent","push","concat","isSomeChildChecked","value","itemKeys","childrenKey","valueKey","some","child","_child$childrenKey","n","length","isSomeParentChecked","getOtherItemValuesByUnselectChild","itemNode","parentValues","itemValues","findParent","item","v","p","pushChildValue","forEach","removeAllChildrenValue","removedValue","useFlattenData","data","_useState","flattenData","setFlattenData","addFlattenData","children","nodes","map","useColumnData","_useState2","filter","columnData","setColumnData","addColumn","column","index","removeColumnByIndex","enforceUpdateColumnData","nextData","nextFlattenData","useCascadeValue","props","uncheckableItemValues","cascade","valueProp","getChildrenValue","values","splitValue","checked","itemValue","childrenValue","nextValue","_loop","i","isCheckableParent","isCheckAll","every","tempValue","uniqValue","uniqRemovedValue","transformValue","tempRemovedValue","_loop2","find","sv","_ret","_useState3","setValue"],"sources":["/Users/peeranat/Desktop/Project/fontend/node_modules/rsuite/esm/MultiCascader/utils.js"],"sourcesContent":["import { useState, useEffect, useCallback } from 'react';\nimport uniq from 'lodash/uniq';\nimport remove from 'lodash/remove';\nimport slice from 'lodash/slice';\nimport { flattenTree } from '../utils/treeUtils';\nimport { attachParent } from '../utils/attachParent';\n\n/**\n * Get all parents of a node\n * @param node\n */\nexport var getParents = function getParents(node) {\n  var parents = [];\n\n  if (!node.parent) {\n    return parents;\n  }\n\n  parents.push(node.parent);\n  parents = parents.concat(getParents(node.parent));\n  return parents;\n};\n/**\n * Check if any child nodes are selected.\n * @param node\n * @param value\n * @param itemKeys\n */\n\nexport var isSomeChildChecked = function isSomeChildChecked(node, value, itemKeys) {\n  var childrenKey = itemKeys.childrenKey,\n      valueKey = itemKeys.valueKey;\n\n  if (!node[childrenKey] || !value) {\n    return false;\n  }\n\n  return node[childrenKey].some(function (child) {\n    var _child$childrenKey;\n\n    if (value.some(function (n) {\n      return n === child[valueKey];\n    })) {\n      return true;\n    }\n\n    if ((_child$childrenKey = child[childrenKey]) !== null && _child$childrenKey !== void 0 && _child$childrenKey.length) {\n      return isSomeChildChecked(child, value, itemKeys);\n    }\n\n    return false;\n  });\n};\n/**\n * Check if the parent is selected.\n * @param node\n * @param value\n * @param itemKeys\n */\n\nexport var isSomeParentChecked = function isSomeParentChecked(node, value, itemKeys) {\n  var valueKey = itemKeys.valueKey;\n\n  if (!value) {\n    return false;\n  }\n\n  if (value.some(function (n) {\n    return n === node[valueKey];\n  })) {\n    return true;\n  }\n\n  if (node.parent) {\n    return isSomeParentChecked(node.parent, value, itemKeys);\n  }\n\n  return false;\n};\nexport var getOtherItemValuesByUnselectChild = function getOtherItemValuesByUnselectChild(itemNode, value, itemKeys) {\n  var valueKey = itemKeys.valueKey,\n      childrenKey = itemKeys.childrenKey;\n  var parentValues = [];\n  var itemValues = []; // Find the parent node of the current node by value\n\n  function findParent(item) {\n    parentValues.push(item[valueKey]);\n\n    if (value.some(function (v) {\n      return v === item[valueKey];\n    })) {\n      return item;\n    }\n\n    if (item.parent) {\n      var p = findParent(item.parent);\n\n      if (p) {\n        return p;\n      }\n    }\n\n    return null;\n  } // Get child nodes through parent node\n\n\n  function pushChildValue(item) {\n    if (!item[childrenKey]) {\n      return;\n    }\n\n    item[childrenKey].forEach(function (n) {\n      // Determine whether it is a direct parent\n      if (parentValues.some(function (v) {\n        return v === n[valueKey];\n      }) && n[childrenKey]) {\n        pushChildValue(n);\n      } else if (n[valueKey] !== itemNode[valueKey]) {\n        itemValues.push(n[valueKey]);\n      }\n    });\n  }\n\n  var parent = findParent(itemNode);\n\n  if (!parent) {\n    return [];\n  }\n\n  pushChildValue(parent);\n  return itemValues;\n};\n/**\n * Remove the values of all children.\n */\n\nexport var removeAllChildrenValue = function removeAllChildrenValue(value, item, itemKeys) {\n  var valueKey = itemKeys.valueKey,\n      childrenKey = itemKeys.childrenKey;\n  var removedValue = [];\n\n  if (!item[childrenKey]) {\n    return;\n  }\n\n  item[childrenKey].forEach(function (n) {\n    removedValue = removedValue.concat(remove(value, function (v) {\n      return v === n[valueKey];\n    }));\n\n    if (n[childrenKey]) {\n      removeAllChildrenValue(value, n, itemKeys);\n    }\n  });\n  return removedValue;\n};\n/**\n * A hook to flatten tree structure data\n * @param data\n */\n\nexport function useFlattenData(data, itemKeys) {\n  var childrenKey = itemKeys.childrenKey;\n\n  var _useState = useState(flattenTree(data, itemKeys.childrenKey)),\n      flattenData = _useState[0],\n      setFlattenData = _useState[1];\n\n  var addFlattenData = useCallback(function (children, parent) {\n    var nodes = children.map(function (child) {\n      return attachParent(child, parent);\n    });\n    parent[childrenKey] = nodes;\n    setFlattenData([].concat(flattenData, nodes));\n  }, [childrenKey, flattenData]);\n  useEffect(function () {\n    setFlattenData(flattenTree(data, itemKeys.childrenKey));\n  }, [data, itemKeys.childrenKey]);\n  return {\n    addFlattenData: addFlattenData,\n    flattenData: flattenData\n  };\n}\n/**\n * A hook for column data\n * @param flattenData\n */\n\nexport function useColumnData(flattenData) {\n  // The columns displayed in the cascading panel.\n  var _useState2 = useState([flattenData.filter(function (item) {\n    return !item.parent;\n  })]),\n      columnData = _useState2[0],\n      setColumnData = _useState2[1];\n  /**\n   * Add a list of options to the cascading panel. Used for lazy loading options.\n   * @param column\n   * @param index The index of the current column.\n   */\n\n\n  function addColumn(column, index) {\n    setColumnData([].concat(slice(columnData, 0, index), [column]));\n  }\n  /**\n   * Remove subsequent columns of the specified column\n   * @param index\n   */\n\n\n  function removeColumnByIndex(index) {\n    setColumnData([].concat(slice(columnData, 0, index)));\n  }\n\n  function enforceUpdateColumnData(nextData) {\n    var nextFlattenData = flattenTree(nextData);\n    setColumnData([nextFlattenData.filter(function (item) {\n      return !item.parent;\n    })]);\n  }\n\n  return {\n    columnData: columnData,\n    addColumn: addColumn,\n    removeColumnByIndex: removeColumnByIndex,\n    setColumnData: setColumnData,\n    enforceUpdateColumnData: enforceUpdateColumnData\n  };\n}\n/**\n * A hook that converts the value into a cascading value\n * @param props\n * @param flattenData\n */\n\nexport function useCascadeValue(props, flattenData) {\n  var valueKey = props.valueKey,\n      childrenKey = props.childrenKey,\n      uncheckableItemValues = props.uncheckableItemValues,\n      cascade = props.cascade,\n      valueProp = props.value;\n  /**\n   * Get the values of all children\n   */\n\n  var getChildrenValue = useCallback(function (item) {\n    var values = [];\n\n    if (!item[childrenKey]) {\n      return values;\n    }\n\n    item[childrenKey].forEach(function (n) {\n      if (uncheckableItemValues && !uncheckableItemValues.some(function (v) {\n        return v === n[valueKey];\n      })) {\n        values.push(n[valueKey]);\n      }\n\n      values = values.concat(getChildrenValue(n));\n    });\n    return values;\n  }, [childrenKey, uncheckableItemValues, valueKey]);\n  var splitValue = useCallback(function (item, checked, value) {\n    var itemValue = item[valueKey];\n    var childrenValue = getChildrenValue(item);\n    var parents = getParents(item);\n    var nextValue = [].concat(value);\n    var removedValue = [];\n\n    if (checked) {\n      nextValue.push(itemValue); // Delete all values under the current node\n\n      removedValue = removedValue.concat(removeAllChildrenValue(nextValue, item, {\n        valueKey: valueKey,\n        childrenKey: childrenKey\n      }) || []); // Traverse all ancestor nodes of the current node\n      // Then determine whether all the child nodes of these nodes are selected, and then they themselves must be selected\n\n      var _loop = function _loop(i) {\n        // Whether the parent node can be selected\n        var isCheckableParent = !(uncheckableItemValues !== null && uncheckableItemValues !== void 0 && uncheckableItemValues.some(function (v) {\n          return v === parents[i][valueKey];\n        }));\n\n        if (isCheckableParent) {\n          var isCheckAll = parents[i][childrenKey] // Filter out options that are marked as not selectable\n          .filter(function (n) {\n            return !(uncheckableItemValues !== null && uncheckableItemValues !== void 0 && uncheckableItemValues.some(function (v) {\n              return v === n[valueKey];\n            }));\n          }) // Check if all nodes are selected\n          .every(function (n) {\n            return nextValue.some(function (v) {\n              return v === n[valueKey];\n            });\n          });\n\n          if (isCheckAll) {\n            // Add parent node value\n            nextValue.push(parents[i][valueKey]); // Delete all values under the parent node\n\n            removedValue = removedValue.concat(removeAllChildrenValue(nextValue, parents[i], {\n              valueKey: valueKey,\n              childrenKey: childrenKey\n            }) || []);\n          }\n        }\n      };\n\n      for (var i = 0; i < parents.length; i++) {\n        _loop(i);\n      }\n    } else {\n      var tempValue = childrenValue.concat(parents.map(function (item) {\n        return item[valueKey];\n      }));\n      nextValue = nextValue.concat(getOtherItemValuesByUnselectChild(item, nextValue, {\n        valueKey: valueKey,\n        childrenKey: childrenKey\n      })); // Delete related child and parent nodes\n\n      removedValue = remove(nextValue, function (v) {\n        // Delete yourself\n        if (v === itemValue) {\n          return true;\n        }\n\n        return tempValue.some(function (n) {\n          return n === v;\n        });\n      });\n    }\n\n    var uniqValue = uniq(nextValue);\n    var uniqRemovedValue = uniq(removedValue);\n    return {\n      value: uniqValue,\n      removedValue: uniqRemovedValue\n    };\n  }, [valueKey, childrenKey, uncheckableItemValues, getChildrenValue]);\n  var transformValue = useCallback(function (value) {\n    if (value === void 0) {\n      value = [];\n    }\n\n    if (!cascade) {\n      return value;\n    }\n\n    var tempRemovedValue = [];\n    var nextValue = [];\n\n    var _loop2 = function _loop2(i) {\n      // If the value in the current value is already in the deleted list, it will not be processed\n      if (tempRemovedValue.some(function (v) {\n        return v === value[i];\n      })) {\n        return \"continue\";\n      }\n\n      var item = flattenData.find(function (v) {\n        return v[valueKey] === value[i];\n      });\n\n      if (!item) {\n        return \"continue\";\n      }\n\n      var sv = splitValue(item, true, value);\n      tempRemovedValue = uniq(tempRemovedValue.concat(sv.removedValue)); // Get all relevant values\n\n      nextValue = uniq(nextValue.concat(sv.value));\n    };\n\n    for (var i = 0; i < value.length; i++) {\n      var _ret = _loop2(i);\n\n      if (_ret === \"continue\") continue;\n    } // Finally traverse all nextValue, and delete if its parent node is also nextValue\n\n\n    return nextValue.filter(function (v) {\n      var item = flattenData.find(function (n) {\n        return n[valueKey] === v;\n      });\n\n      if (item !== null && item !== void 0 && item.parent && nextValue.some(function (v) {\n        return v === item.parent && item.parent[valueKey];\n      })) {\n        return false;\n      }\n\n      return true;\n    });\n  }, [cascade, flattenData, splitValue, valueKey]);\n\n  var _useState3 = useState(transformValue(valueProp) || []),\n      value = _useState3[0],\n      setValue = _useState3[1];\n\n  useEffect(function () {\n    // Update value when valueProp is updated.\n    setValue(transformValue(valueProp) || []);\n  }, [transformValue, valueProp]);\n  return {\n    value: value,\n    setValue: setValue,\n    splitValue: splitValue\n  };\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}