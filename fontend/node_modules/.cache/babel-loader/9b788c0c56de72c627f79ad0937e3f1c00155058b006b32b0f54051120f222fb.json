{"ast":null,"code":"import { convertMaskToPlaceholder, processCaretTraps, defaultPlaceholderChar } from './utilities';\nexport function isArray(value) {\n  return Array.isArray && Array.isArray(value) || value instanceof Array;\n}\nexport default function conformToMask(rawValue, mask, config) {\n  if (rawValue === void 0) {\n    rawValue = '';\n  }\n  if (mask === void 0) {\n    mask = [];\n  }\n  if (config === void 0) {\n    config = {};\n  }\n  if (!isArray(mask)) {\n    // If someone passes a function as the mask property, we should call the\n    // function to get the mask array - Normally this is handled by the\n    // `createTextMaskInputElement:update` function - this allows mask functions\n    // to be used directly with `conformToMask`\n    if (typeof mask === 'function') {\n      // call the mask function to get the mask array\n      mask = mask(rawValue, config); // mask functions can setup caret traps to have some control over how the caret moves. We need to process\n      // the mask for any caret traps. `processCaretTraps` will remove the caret traps from the mask\n\n      mask = processCaretTraps(mask).maskWithoutCaretTraps;\n    } else {\n      throw new Error('Text-mask:conformToMask; The mask property must be an array.');\n    }\n  } // These configurations tell us how to conform the mask\n\n  var _config = config,\n    _config$guide = _config.guide,\n    guide = _config$guide === void 0 ? true : _config$guide,\n    _config$previousConfo = _config.previousConformedValue,\n    previousConformedValue = _config$previousConfo === void 0 ? '' : _config$previousConfo,\n    _config$placeholderCh = _config.placeholderChar,\n    placeholderChar = _config$placeholderCh === void 0 ? defaultPlaceholderChar : _config$placeholderCh,\n    _config$placeholder = _config.placeholder,\n    placeholder = _config$placeholder === void 0 ? convertMaskToPlaceholder(mask, placeholderChar) : _config$placeholder,\n    _config$currentCaretP = _config.currentCaretPosition,\n    currentCaretPosition = _config$currentCaretP === void 0 ? 0 : _config$currentCaretP,\n    keepCharPositions = _config.keepCharPositions; // The configs below indicate that the user wants the algorithm to work in *no guide* mode\n\n  var suppressGuide = guide === false && previousConformedValue !== undefined; // Calculate lengths once for performance\n\n  var rawValueLength = rawValue.length;\n  var previousConformedValueLength = previousConformedValue.length;\n  var placeholderLength = placeholder.length;\n  var maskLength = mask.length; // This tells us the number of edited characters and the direction in which they were edited (+/-)\n\n  var editDistance = rawValueLength - previousConformedValueLength; // In *no guide* mode, we need to know if the user is trying to add a character or not\n\n  var isAddition = editDistance > 0; // Tells us the index of the first change. For (438) 394-4938 to (38) 394-4938, that would be 1\n\n  var indexOfFirstChange = currentCaretPosition + (isAddition ? -editDistance : 0); // We're also gonna need the index of last change, which we can derive as follows...\n\n  var indexOfLastChange = indexOfFirstChange + Math.abs(editDistance); // If `conformToMask` is configured to keep character positions, that is, for mask 111, previous value\n  // _2_ and raw value 3_2_, the new conformed value should be 32_, not 3_2 (default behavior). That's in the case of\n  // addition. And in the case of deletion, previous value _23, raw value _3, the new conformed string should be\n  // __3, not _3_ (default behavior)\n  //\n  // The next block of logic handles keeping character positions for the case of deletion. (Keeping\n  // character positions for the case of addition is further down since it is handled differently.)\n  // To do this, we want to compensate for all characters that were deleted\n\n  if (keepCharPositions === true && !isAddition) {\n    // We will be storing the new placeholder characters in this variable.\n    var compensatingPlaceholderChars = ''; // For every character that was deleted from a placeholder position, we add a placeholder char\n\n    for (var i = indexOfFirstChange; i < indexOfLastChange; i++) {\n      if (placeholder[i] === placeholderChar) {\n        compensatingPlaceholderChars += placeholderChar;\n      }\n    } // Now we trick our algorithm by modifying the raw value to make it contain additional placeholder characters\n    // That way when the we start laying the characters again on the mask, it will keep the non-deleted characters\n    // in their positions.\n\n    rawValue = rawValue.slice(0, indexOfFirstChange) + compensatingPlaceholderChars + rawValue.slice(indexOfFirstChange, rawValueLength);\n  } // Convert `rawValue` string to an array, and mark characters based on whether they are newly added or have\n  // existed in the previous conformed value. Identifying new and old characters is needed for `conformToMask`\n  // to work if it is configured to keep character positions.\n\n  var rawValueArr = rawValue.split('').map(function (char, i) {\n    return {\n      char: char,\n      isNew: i >= indexOfFirstChange && i < indexOfLastChange\n    };\n  }); // The loop below removes masking characters from user input. For example, for mask\n  // `00 (111)`, the placeholder would be `00 (___)`. If user input is `00 (234)`, the loop below\n  // would remove all characters but `234` from the `rawValueArr`. The rest of the algorithm\n  // then would lay `234` on top of the available placeholder positions in the mask.\n\n  for (var _i = rawValueLength - 1; _i >= 0; _i--) {\n    var char = rawValueArr[_i].char;\n    if (char !== placeholderChar) {\n      var shouldOffset = _i >= indexOfFirstChange && previousConformedValueLength === maskLength;\n      if (char === placeholder[shouldOffset ? _i - editDistance : _i]) {\n        rawValueArr.splice(_i, 1);\n      }\n    }\n  } // This is the variable that we will be filling with characters as we figure them out\n  // in the algorithm below\n\n  var conformedValue = '';\n  var someCharsRejected = false; // Ok, so first we loop through the placeholder looking for placeholder characters to fill up.\n\n  placeholderLoop: for (var _i2 = 0; _i2 < placeholderLength; _i2++) {\n    var charInPlaceholder = placeholder[_i2]; // We see one. Let's find out what we can put in it.\n\n    if (charInPlaceholder === placeholderChar) {\n      // But before that, do we actually have any user characters that need a place?\n      if (rawValueArr.length > 0) {\n        // We will keep chipping away at user input until either we run out of characters\n        // or we find at least one character that we can map.\n        while (rawValueArr.length > 0) {\n          // Let's retrieve the first user character in the queue of characters we have left\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          var _ref = rawValueArr.shift(),\n            rawValueChar = _ref.char,\n            isNew = _ref.isNew; // If the character we got from the user input is a placeholder character (which happens\n          // regularly because user input could be something like (540) 90_-____, which includes\n          // a bunch of `_` which are placeholder characters) and we are not in *no guide* mode,\n          // then we map this placeholder character to the current spot in the placeholder\n\n          if (rawValueChar === placeholderChar && suppressGuide !== true) {\n            conformedValue += placeholderChar; // And we go to find the next placeholder character that needs filling\n\n            continue placeholderLoop; // Else if, the character we got from the user input is not a placeholder, let's see\n            // if the current position in the mask can accept it.\n          } else if (mask[_i2].test(rawValueChar)) {\n            // we map the character differently based on whether we are keeping character positions or not.\n            // If any of the conditions below are met, we simply map the raw value character to the\n            // placeholder position.\n            if (keepCharPositions !== true || isNew === false || previousConformedValue === '' || guide === false || !isAddition) {\n              conformedValue += rawValueChar;\n            } else {\n              // We enter this block of code if we are trying to keep character positions and none of the conditions\n              // above is met. In this case, we need to see if there's an available spot for the raw value character\n              // to be mapped to. If we couldn't find a spot, we will discard the character.\n              //\n              // For example, for mask `1111`, previous conformed value `_2__`, raw value `942_2__`. We can map the\n              // `9`, to the first available placeholder position, but then, there are no more spots available for the\n              // `4` and `2`. So, we discard them and end up with a conformed value of `92__`.\n              var rawValueArrLength = rawValueArr.length;\n              var indexOfNextAvailablePlaceholderChar = null; // Let's loop through the remaining raw value characters. We are looking for either a suitable spot, ie,\n              // a placeholder character or a non-suitable spot, ie, a non-placeholder character that is not new.\n              // If we see a suitable spot first, we store its position and exit the loop. If we see a non-suitable\n              // spot first, we exit the loop and our `indexOfNextAvailablePlaceholderChar` will stay as `null`.\n\n              for (var _i3 = 0; _i3 < rawValueArrLength; _i3++) {\n                var charData = rawValueArr[_i3];\n                if (charData.char !== placeholderChar && charData.isNew === false) {\n                  break;\n                }\n                if (charData.char === placeholderChar) {\n                  indexOfNextAvailablePlaceholderChar = _i3;\n                  break;\n                }\n              } // If `indexOfNextAvailablePlaceholderChar` is not `null`, that means the character is not blocked.\n              // We can map it. And to keep the character positions, we remove the placeholder character\n              // from the remaining characters\n\n              if (indexOfNextAvailablePlaceholderChar !== null) {\n                conformedValue += rawValueChar;\n                rawValueArr.splice(indexOfNextAvailablePlaceholderChar, 1); // If `indexOfNextAvailablePlaceholderChar` is `null`, that means the character is blocked. We have to\n                // discard it.\n              } else {\n                _i2--;\n              }\n            } // Since we've mapped this placeholder position. We move on to the next one.\n\n            continue placeholderLoop;\n          } else {\n            someCharsRejected = true;\n          }\n        }\n      } // We reach this point when we've mapped all the user input characters to placeholder\n      // positions in the mask. In *guide* mode, we append the left over characters in the\n      // placeholder to the `conformedString`, but in *no guide* mode, we don't wanna do that.\n      //\n      // That is, for mask `(111)` and user input `2`, we want to return `(2`, not `(2__)`.\n\n      if (suppressGuide === false) {\n        conformedValue += placeholder.substr(_i2, placeholderLength);\n      } // And we break\n\n      break; // Else, the charInPlaceholder is not a placeholderChar. That is, we cannot fill it\n      // with user input. So we just map it to the final output\n    } else {\n      conformedValue += charInPlaceholder;\n    }\n  } // The following logic is needed to deal with the case of deletion in *no guide* mode.\n  //\n  // Consider the silly mask `(111) /// 1`. What if user tries to delete the last placeholder\n  // position? Something like `(589) /// `. We want to conform that to `(589`. Not `(589) /// `.\n  // That's why the logic below finds the last filled placeholder character, and removes everything\n  // from that point on.\n\n  if (suppressGuide && isAddition === false) {\n    var indexOfLastFilledPlaceholderChar = null; // Find the last filled placeholder position and substring from there\n\n    for (var _i4 = 0; _i4 < conformedValue.length; _i4++) {\n      if (placeholder[_i4] === placeholderChar) {\n        indexOfLastFilledPlaceholderChar = _i4;\n      }\n    }\n    if (indexOfLastFilledPlaceholderChar !== null) {\n      // We substring from the beginning until the position after the last filled placeholder char.\n      conformedValue = conformedValue.substr(0, indexOfLastFilledPlaceholderChar + 1);\n    } else {\n      // If we couldn't find `indexOfLastFilledPlaceholderChar` that means the user deleted\n      // the first character in the mask. So we return an empty string.\n      conformedValue = '';\n    }\n  }\n  return {\n    conformedValue: conformedValue,\n    meta: {\n      someCharsRejected: someCharsRejected\n    }\n  };\n}","map":{"version":3,"names":["convertMaskToPlaceholder","processCaretTraps","defaultPlaceholderChar","isArray","value","Array","conformToMask","rawValue","mask","config","maskWithoutCaretTraps","Error","_config","_config$guide","guide","_config$previousConfo","previousConformedValue","_config$placeholderCh","placeholderChar","_config$placeholder","placeholder","_config$currentCaretP","currentCaretPosition","keepCharPositions","suppressGuide","undefined","rawValueLength","length","previousConformedValueLength","placeholderLength","maskLength","editDistance","isAddition","indexOfFirstChange","indexOfLastChange","Math","abs","compensatingPlaceholderChars","i","slice","rawValueArr","split","map","char","isNew","_i","shouldOffset","splice","conformedValue","someCharsRejected","placeholderLoop","_i2","charInPlaceholder","_ref","shift","rawValueChar","test","rawValueArrLength","indexOfNextAvailablePlaceholderChar","_i3","charData","substr","indexOfLastFilledPlaceholderChar","_i4","meta"],"sources":["/Users/peeranat/Desktop/Project copy 2/fontend/node_modules/rsuite/esm/MaskedInput/conformToMask.js"],"sourcesContent":["import { convertMaskToPlaceholder, processCaretTraps, defaultPlaceholderChar } from './utilities';\nexport function isArray(value) {\n  return Array.isArray && Array.isArray(value) || value instanceof Array;\n}\nexport default function conformToMask(rawValue, mask, config) {\n  if (rawValue === void 0) {\n    rawValue = '';\n  }\n\n  if (mask === void 0) {\n    mask = [];\n  }\n\n  if (config === void 0) {\n    config = {};\n  }\n\n  if (!isArray(mask)) {\n    // If someone passes a function as the mask property, we should call the\n    // function to get the mask array - Normally this is handled by the\n    // `createTextMaskInputElement:update` function - this allows mask functions\n    // to be used directly with `conformToMask`\n    if (typeof mask === 'function') {\n      // call the mask function to get the mask array\n      mask = mask(rawValue, config); // mask functions can setup caret traps to have some control over how the caret moves. We need to process\n      // the mask for any caret traps. `processCaretTraps` will remove the caret traps from the mask\n\n      mask = processCaretTraps(mask).maskWithoutCaretTraps;\n    } else {\n      throw new Error('Text-mask:conformToMask; The mask property must be an array.');\n    }\n  } // These configurations tell us how to conform the mask\n\n\n  var _config = config,\n      _config$guide = _config.guide,\n      guide = _config$guide === void 0 ? true : _config$guide,\n      _config$previousConfo = _config.previousConformedValue,\n      previousConformedValue = _config$previousConfo === void 0 ? '' : _config$previousConfo,\n      _config$placeholderCh = _config.placeholderChar,\n      placeholderChar = _config$placeholderCh === void 0 ? defaultPlaceholderChar : _config$placeholderCh,\n      _config$placeholder = _config.placeholder,\n      placeholder = _config$placeholder === void 0 ? convertMaskToPlaceholder(mask, placeholderChar) : _config$placeholder,\n      _config$currentCaretP = _config.currentCaretPosition,\n      currentCaretPosition = _config$currentCaretP === void 0 ? 0 : _config$currentCaretP,\n      keepCharPositions = _config.keepCharPositions; // The configs below indicate that the user wants the algorithm to work in *no guide* mode\n\n  var suppressGuide = guide === false && previousConformedValue !== undefined; // Calculate lengths once for performance\n\n  var rawValueLength = rawValue.length;\n  var previousConformedValueLength = previousConformedValue.length;\n  var placeholderLength = placeholder.length;\n  var maskLength = mask.length; // This tells us the number of edited characters and the direction in which they were edited (+/-)\n\n  var editDistance = rawValueLength - previousConformedValueLength; // In *no guide* mode, we need to know if the user is trying to add a character or not\n\n  var isAddition = editDistance > 0; // Tells us the index of the first change. For (438) 394-4938 to (38) 394-4938, that would be 1\n\n  var indexOfFirstChange = currentCaretPosition + (isAddition ? -editDistance : 0); // We're also gonna need the index of last change, which we can derive as follows...\n\n  var indexOfLastChange = indexOfFirstChange + Math.abs(editDistance); // If `conformToMask` is configured to keep character positions, that is, for mask 111, previous value\n  // _2_ and raw value 3_2_, the new conformed value should be 32_, not 3_2 (default behavior). That's in the case of\n  // addition. And in the case of deletion, previous value _23, raw value _3, the new conformed string should be\n  // __3, not _3_ (default behavior)\n  //\n  // The next block of logic handles keeping character positions for the case of deletion. (Keeping\n  // character positions for the case of addition is further down since it is handled differently.)\n  // To do this, we want to compensate for all characters that were deleted\n\n  if (keepCharPositions === true && !isAddition) {\n    // We will be storing the new placeholder characters in this variable.\n    var compensatingPlaceholderChars = ''; // For every character that was deleted from a placeholder position, we add a placeholder char\n\n    for (var i = indexOfFirstChange; i < indexOfLastChange; i++) {\n      if (placeholder[i] === placeholderChar) {\n        compensatingPlaceholderChars += placeholderChar;\n      }\n    } // Now we trick our algorithm by modifying the raw value to make it contain additional placeholder characters\n    // That way when the we start laying the characters again on the mask, it will keep the non-deleted characters\n    // in their positions.\n\n\n    rawValue = rawValue.slice(0, indexOfFirstChange) + compensatingPlaceholderChars + rawValue.slice(indexOfFirstChange, rawValueLength);\n  } // Convert `rawValue` string to an array, and mark characters based on whether they are newly added or have\n  // existed in the previous conformed value. Identifying new and old characters is needed for `conformToMask`\n  // to work if it is configured to keep character positions.\n\n\n  var rawValueArr = rawValue.split('').map(function (char, i) {\n    return {\n      char: char,\n      isNew: i >= indexOfFirstChange && i < indexOfLastChange\n    };\n  }); // The loop below removes masking characters from user input. For example, for mask\n  // `00 (111)`, the placeholder would be `00 (___)`. If user input is `00 (234)`, the loop below\n  // would remove all characters but `234` from the `rawValueArr`. The rest of the algorithm\n  // then would lay `234` on top of the available placeholder positions in the mask.\n\n  for (var _i = rawValueLength - 1; _i >= 0; _i--) {\n    var char = rawValueArr[_i].char;\n\n    if (char !== placeholderChar) {\n      var shouldOffset = _i >= indexOfFirstChange && previousConformedValueLength === maskLength;\n\n      if (char === placeholder[shouldOffset ? _i - editDistance : _i]) {\n        rawValueArr.splice(_i, 1);\n      }\n    }\n  } // This is the variable that we will be filling with characters as we figure them out\n  // in the algorithm below\n\n\n  var conformedValue = '';\n  var someCharsRejected = false; // Ok, so first we loop through the placeholder looking for placeholder characters to fill up.\n\n  placeholderLoop: for (var _i2 = 0; _i2 < placeholderLength; _i2++) {\n    var charInPlaceholder = placeholder[_i2]; // We see one. Let's find out what we can put in it.\n\n    if (charInPlaceholder === placeholderChar) {\n      // But before that, do we actually have any user characters that need a place?\n      if (rawValueArr.length > 0) {\n        // We will keep chipping away at user input until either we run out of characters\n        // or we find at least one character that we can map.\n        while (rawValueArr.length > 0) {\n          // Let's retrieve the first user character in the queue of characters we have left\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          var _ref = rawValueArr.shift(),\n              rawValueChar = _ref.char,\n              isNew = _ref.isNew; // If the character we got from the user input is a placeholder character (which happens\n          // regularly because user input could be something like (540) 90_-____, which includes\n          // a bunch of `_` which are placeholder characters) and we are not in *no guide* mode,\n          // then we map this placeholder character to the current spot in the placeholder\n\n\n          if (rawValueChar === placeholderChar && suppressGuide !== true) {\n            conformedValue += placeholderChar; // And we go to find the next placeholder character that needs filling\n\n            continue placeholderLoop; // Else if, the character we got from the user input is not a placeholder, let's see\n            // if the current position in the mask can accept it.\n          } else if (mask[_i2].test(rawValueChar)) {\n            // we map the character differently based on whether we are keeping character positions or not.\n            // If any of the conditions below are met, we simply map the raw value character to the\n            // placeholder position.\n            if (keepCharPositions !== true || isNew === false || previousConformedValue === '' || guide === false || !isAddition) {\n              conformedValue += rawValueChar;\n            } else {\n              // We enter this block of code if we are trying to keep character positions and none of the conditions\n              // above is met. In this case, we need to see if there's an available spot for the raw value character\n              // to be mapped to. If we couldn't find a spot, we will discard the character.\n              //\n              // For example, for mask `1111`, previous conformed value `_2__`, raw value `942_2__`. We can map the\n              // `9`, to the first available placeholder position, but then, there are no more spots available for the\n              // `4` and `2`. So, we discard them and end up with a conformed value of `92__`.\n              var rawValueArrLength = rawValueArr.length;\n              var indexOfNextAvailablePlaceholderChar = null; // Let's loop through the remaining raw value characters. We are looking for either a suitable spot, ie,\n              // a placeholder character or a non-suitable spot, ie, a non-placeholder character that is not new.\n              // If we see a suitable spot first, we store its position and exit the loop. If we see a non-suitable\n              // spot first, we exit the loop and our `indexOfNextAvailablePlaceholderChar` will stay as `null`.\n\n              for (var _i3 = 0; _i3 < rawValueArrLength; _i3++) {\n                var charData = rawValueArr[_i3];\n\n                if (charData.char !== placeholderChar && charData.isNew === false) {\n                  break;\n                }\n\n                if (charData.char === placeholderChar) {\n                  indexOfNextAvailablePlaceholderChar = _i3;\n                  break;\n                }\n              } // If `indexOfNextAvailablePlaceholderChar` is not `null`, that means the character is not blocked.\n              // We can map it. And to keep the character positions, we remove the placeholder character\n              // from the remaining characters\n\n\n              if (indexOfNextAvailablePlaceholderChar !== null) {\n                conformedValue += rawValueChar;\n                rawValueArr.splice(indexOfNextAvailablePlaceholderChar, 1); // If `indexOfNextAvailablePlaceholderChar` is `null`, that means the character is blocked. We have to\n                // discard it.\n              } else {\n                _i2--;\n              }\n            } // Since we've mapped this placeholder position. We move on to the next one.\n\n\n            continue placeholderLoop;\n          } else {\n            someCharsRejected = true;\n          }\n        }\n      } // We reach this point when we've mapped all the user input characters to placeholder\n      // positions in the mask. In *guide* mode, we append the left over characters in the\n      // placeholder to the `conformedString`, but in *no guide* mode, we don't wanna do that.\n      //\n      // That is, for mask `(111)` and user input `2`, we want to return `(2`, not `(2__)`.\n\n\n      if (suppressGuide === false) {\n        conformedValue += placeholder.substr(_i2, placeholderLength);\n      } // And we break\n\n\n      break; // Else, the charInPlaceholder is not a placeholderChar. That is, we cannot fill it\n      // with user input. So we just map it to the final output\n    } else {\n      conformedValue += charInPlaceholder;\n    }\n  } // The following logic is needed to deal with the case of deletion in *no guide* mode.\n  //\n  // Consider the silly mask `(111) /// 1`. What if user tries to delete the last placeholder\n  // position? Something like `(589) /// `. We want to conform that to `(589`. Not `(589) /// `.\n  // That's why the logic below finds the last filled placeholder character, and removes everything\n  // from that point on.\n\n\n  if (suppressGuide && isAddition === false) {\n    var indexOfLastFilledPlaceholderChar = null; // Find the last filled placeholder position and substring from there\n\n    for (var _i4 = 0; _i4 < conformedValue.length; _i4++) {\n      if (placeholder[_i4] === placeholderChar) {\n        indexOfLastFilledPlaceholderChar = _i4;\n      }\n    }\n\n    if (indexOfLastFilledPlaceholderChar !== null) {\n      // We substring from the beginning until the position after the last filled placeholder char.\n      conformedValue = conformedValue.substr(0, indexOfLastFilledPlaceholderChar + 1);\n    } else {\n      // If we couldn't find `indexOfLastFilledPlaceholderChar` that means the user deleted\n      // the first character in the mask. So we return an empty string.\n      conformedValue = '';\n    }\n  }\n\n  return {\n    conformedValue: conformedValue,\n    meta: {\n      someCharsRejected: someCharsRejected\n    }\n  };\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}