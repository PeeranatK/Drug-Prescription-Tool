{"ast":null,"code":"import maxBy from 'lodash/maxBy';\nimport minBy from 'lodash/minBy';\nimport kebabCase from 'lodash/kebabCase';\nimport ownerDocument from 'dom-lib/ownerDocument';\nimport getOffset from 'dom-lib/getOffset';\nimport scrollTop from 'dom-lib/scrollTop';\nimport scrollLeft from 'dom-lib/scrollLeft';\nimport _getPosition from 'dom-lib/getPosition';\nimport getStyle from 'dom-lib/getStyle';\nimport nodeName from 'dom-lib/nodeName';\nexport var AutoPlacement = {\n  left: 'Start',\n  right: 'End',\n  top: 'Start',\n  bottom: 'End'\n};\n\n/**\n * Get the external dimensions of the container\n * @param containerNode\n */\nfunction getContainerDimensions(containerNode) {\n  var width;\n  var height;\n  var scrollX;\n  var scrollY;\n  if (containerNode.tagName === 'BODY') {\n    width = window.innerWidth;\n    height = window.innerHeight;\n    scrollY = scrollTop(ownerDocument(containerNode).documentElement) || scrollTop(containerNode);\n    scrollX = scrollLeft(ownerDocument(containerNode).documentElement) || scrollLeft(containerNode);\n  } else {\n    var _ref = getOffset(containerNode);\n    width = _ref.width;\n    height = _ref.height;\n    scrollY = scrollTop(containerNode);\n    scrollX = scrollLeft(containerNode);\n  }\n  return {\n    width: width,\n    height: height,\n    scrollX: scrollX,\n    scrollY: scrollY\n  };\n}\nexport default (function (props) {\n  var placement = props.placement,\n    preventOverflow = props.preventOverflow,\n    padding = props.padding;\n  function getTopDelta(top, overlayHeight, container) {\n    if (!preventOverflow) {\n      return 0;\n    }\n    var containerDimensions = getContainerDimensions(container);\n    var containerHeight = containerDimensions.height,\n      scrollY = containerDimensions.scrollY;\n    var topEdgeOffset = top - padding - scrollY;\n    var bottomEdgeOffset = top + padding + overlayHeight - scrollY;\n    if (topEdgeOffset < 0) {\n      return -topEdgeOffset;\n    } else if (bottomEdgeOffset > containerHeight) {\n      return containerHeight - bottomEdgeOffset;\n    }\n    return 0;\n  }\n  function getLeftDelta(left, overlayWidth, container) {\n    if (!preventOverflow) {\n      return 0;\n    }\n    var containerDimensions = getContainerDimensions(container);\n    var scrollX = containerDimensions.scrollX,\n      containerWidth = containerDimensions.width;\n    var leftEdgeOffset = left - padding - scrollX;\n    var rightEdgeOffset = left + padding + overlayWidth - scrollX;\n    if (leftEdgeOffset < 0) {\n      return -leftEdgeOffset;\n    } else if (rightEdgeOffset > containerWidth) {\n      return containerWidth - rightEdgeOffset;\n    }\n    return 0;\n  }\n  function getPositionTop(container, overlayHeight, top) {\n    if (!preventOverflow) {\n      return top;\n    }\n    var _getContainerDimensio = getContainerDimensions(container),\n      scrollY = _getContainerDimensio.scrollY,\n      containerHeight = _getContainerDimensio.height; // 判断 overlay 底部是否溢出，设置 top\n\n    if (overlayHeight + top > containerHeight + scrollY) {\n      return containerHeight - overlayHeight + scrollY;\n    } // top 的最小值不能少于纵向滚动条 y 的值\n\n    return Math.max(scrollY, top);\n  }\n  function getPositionLeft(container, overlayWidth, left) {\n    if (!preventOverflow) {\n      return left;\n    }\n    var _getContainerDimensio2 = getContainerDimensions(container),\n      scrollX = _getContainerDimensio2.scrollX,\n      containerWidth = _getContainerDimensio2.width;\n    if (overlayWidth + left > containerWidth + scrollX) {\n      return containerWidth - overlayWidth + scrollX;\n    } // left 的最小值不能少于横向滚动条 x 的值\n\n    return Math.max(scrollX, left);\n  }\n  return {\n    getPosition: function getPosition(target, container) {\n      var offset = container.tagName === 'BODY' ? getOffset(target) : _getPosition(target, container, false);\n      return offset;\n    },\n    getCursorOffsetPosition: function getCursorOffsetPosition(target, container, cursorPosition) {\n      var left = cursorPosition.left,\n        top = cursorPosition.top,\n        clientLeft = cursorPosition.clientLeft,\n        clientTop = cursorPosition.clientTop;\n      var offset = {\n        left: left,\n        top: top,\n        width: 10,\n        height: 10\n      };\n      if (getStyle(target, 'position') === 'fixed') {\n        offset.left = clientLeft;\n        offset.top = clientTop;\n        return offset;\n      }\n      if (container.tagName === 'BODY') {\n        return offset;\n      }\n      var containerOffset = {\n        top: 0,\n        left: 0\n      };\n      if (nodeName(container) !== 'html') {\n        var nextParentOffset = getOffset(container);\n        if (nextParentOffset) {\n          containerOffset.top = nextParentOffset.top;\n          containerOffset.left = nextParentOffset.left;\n        }\n      }\n      containerOffset.top += parseInt(getStyle(container, 'borderTopWidth'), 10) - scrollTop(container) || 0;\n      containerOffset.left += parseInt(getStyle(container, 'borderLeftWidth'), 10) - scrollLeft(container) || 0;\n      offset.left = left - containerOffset.left;\n      offset.top = top - containerOffset.top;\n      return offset;\n    },\n    calcAutoPlacement: function calcAutoPlacement(targetOffset, container, overlay) {\n      var _getContainerDimensio3 = getContainerDimensions(container),\n        width = _getContainerDimensio3.width,\n        height = _getContainerDimensio3.height,\n        scrollX = _getContainerDimensio3.scrollX,\n        scrollY = _getContainerDimensio3.scrollY;\n      var left = targetOffset.left - scrollX - overlay.width;\n      var top = targetOffset.top - scrollY - overlay.height;\n      var right = width - targetOffset.left - targetOffset.width + scrollX - overlay.width;\n      var bottom = height - targetOffset.top - targetOffset.height + scrollY - overlay.height;\n      var horizontal = [{\n        key: 'left',\n        value: left\n      }, {\n        key: 'right',\n        value: right\n      }];\n      var vertical = [{\n        key: 'top',\n        value: top\n      }, {\n        key: 'bottom',\n        value: bottom\n      }];\n      var AV = 'autoVertical';\n      var AH = 'autoHorizontal';\n      var direction;\n      var align;\n      if (placement.indexOf(AV) !== -1) {\n        direction = maxBy(vertical, function (o) {\n          return o.value;\n        });\n        return placement === AV ? direction.key : \"\" + direction.key + placement.replace(AV, '');\n      } else if (placement.indexOf(AH) !== -1) {\n        direction = maxBy(horizontal, function (o) {\n          return o.value;\n        });\n        return placement === AH ? direction.key : \"\" + direction.key + placement.replace(AH, '');\n      }\n      /**\n       * Precedence Vertical\n       * [...vertical, ...horizontal]\n       */\n\n      direction = maxBy([].concat(vertical, horizontal), function (o) {\n        return o.value;\n      });\n      if (direction.key === 'left' || direction.key === 'right') {\n        align = minBy(vertical, function (o) {\n          return o.value;\n        });\n      } else {\n        align = minBy(horizontal, function (o) {\n          return o.value;\n        });\n      }\n      return \"\" + direction.key + AutoPlacement[align.key];\n    },\n    // Calculate the position of the overlay\n    calcOverlayPosition: function calcOverlayPosition(overlayNode, target, container, cursorPosition) {\n      var childOffset = cursorPosition ? this.getCursorOffsetPosition(target, container, cursorPosition) : this.getPosition(target, container);\n      var _ref2 = getOffset(overlayNode),\n        overlayHeight = _ref2.height,\n        overlayWidth = _ref2.width;\n      var top = childOffset.top,\n        left = childOffset.left;\n      var nextPlacement = placement;\n      if (placement && placement.indexOf('auto') >= 0) {\n        nextPlacement = this.calcAutoPlacement(childOffset, container, {\n          height: overlayHeight,\n          width: overlayWidth\n        });\n      }\n      var positionLeft;\n      var positionTop;\n      var arrowOffsetLeft;\n      var arrowOffsetTop;\n      if (nextPlacement === 'left' || nextPlacement === 'right') {\n        positionTop = childOffset.top + (childOffset.height - overlayHeight) / 2;\n        var topDelta = getTopDelta(positionTop, overlayHeight, container);\n        positionTop += topDelta;\n        arrowOffsetTop = 50 * (1 - 2 * topDelta / overlayHeight) + \"%\";\n        arrowOffsetLeft = undefined;\n      } else if (nextPlacement === 'top' || nextPlacement === 'bottom') {\n        positionLeft = left + (childOffset.width - overlayWidth) / 2;\n        var leftDelta = getLeftDelta(positionLeft, overlayWidth, container);\n        positionLeft += leftDelta;\n        arrowOffsetLeft = 50 * (1 - 2 * leftDelta / overlayWidth) + \"%\";\n        arrowOffsetTop = undefined;\n      }\n      if (nextPlacement === 'top' || nextPlacement === 'topStart' || nextPlacement === 'topEnd') {\n        positionTop = getPositionTop(container, overlayHeight, childOffset.top - overlayHeight);\n      }\n      if (nextPlacement === 'bottom' || nextPlacement === 'bottomStart' || nextPlacement === 'bottomEnd') {\n        positionTop = getPositionTop(container, overlayHeight, childOffset.top + childOffset.height);\n      }\n      if (nextPlacement === 'left' || nextPlacement === 'leftStart' || nextPlacement === 'leftEnd') {\n        positionLeft = getPositionLeft(container, overlayWidth, childOffset.left - overlayWidth);\n      }\n      if (nextPlacement === 'right' || nextPlacement === 'rightStart' || nextPlacement === 'rightEnd') {\n        positionLeft = getPositionLeft(container, overlayWidth, childOffset.left + childOffset.width);\n      }\n      if (document.dir === 'rtl' && (nextPlacement === 'left' || nextPlacement === 'leftStart' || nextPlacement === 'leftEnd' || nextPlacement === 'right' || nextPlacement === 'rightStart' || nextPlacement === 'rightEnd')) {\n        /**\n         * When laying out in rtl, if the width of the container\n         * is less than the width of the container scrolling,\n         * you need to recalculate the left value.\n         */\n        var _getContainerDimensio4 = getContainerDimensions(container),\n          containerWidth = _getContainerDimensio4.width;\n        if (container.scrollWidth > containerWidth) {\n          positionLeft = containerWidth + positionLeft - container.scrollWidth;\n        }\n      }\n      if (nextPlacement === 'topStart' || nextPlacement === 'bottomStart') {\n        if (document.dir === 'rtl') {\n          var nextLeft = left + (childOffset.width - overlayWidth);\n          positionLeft = nextLeft + getLeftDelta(nextLeft, overlayWidth, container);\n        } else {\n          positionLeft = left + getLeftDelta(left, overlayWidth, container);\n        }\n      }\n      if (nextPlacement === 'topEnd' || nextPlacement === 'bottomEnd') {\n        if (document.dir === 'rtl') {\n          positionLeft = left + getLeftDelta(left, overlayWidth, container);\n        } else {\n          var _nextLeft = left + (childOffset.width - overlayWidth);\n          positionLeft = _nextLeft + getLeftDelta(_nextLeft, overlayWidth, container);\n        }\n      }\n      if (nextPlacement === 'leftStart' || nextPlacement === 'rightStart') {\n        positionTop = top + getTopDelta(top, overlayHeight, container);\n      }\n      if (nextPlacement === 'leftEnd' || nextPlacement === 'rightEnd') {\n        var nextTop = top + (childOffset.height - overlayHeight);\n        positionTop = nextTop + getTopDelta(nextTop, overlayHeight, container);\n      }\n      return {\n        positionLeft: positionLeft,\n        positionTop: positionTop,\n        arrowOffsetLeft: arrowOffsetLeft,\n        arrowOffsetTop: arrowOffsetTop,\n        positionClassName: \"placement-\" + kebabCase(nextPlacement)\n      };\n    }\n  };\n});","map":{"version":3,"names":["maxBy","minBy","kebabCase","ownerDocument","getOffset","scrollTop","scrollLeft","_getPosition","getStyle","nodeName","AutoPlacement","left","right","top","bottom","getContainerDimensions","containerNode","width","height","scrollX","scrollY","tagName","window","innerWidth","innerHeight","documentElement","_ref","props","placement","preventOverflow","padding","getTopDelta","overlayHeight","container","containerDimensions","containerHeight","topEdgeOffset","bottomEdgeOffset","getLeftDelta","overlayWidth","containerWidth","leftEdgeOffset","rightEdgeOffset","getPositionTop","_getContainerDimensio","Math","max","getPositionLeft","_getContainerDimensio2","getPosition","target","offset","getCursorOffsetPosition","cursorPosition","clientLeft","clientTop","containerOffset","nextParentOffset","parseInt","calcAutoPlacement","targetOffset","overlay","_getContainerDimensio3","horizontal","key","value","vertical","AV","AH","direction","align","indexOf","o","replace","concat","calcOverlayPosition","overlayNode","childOffset","_ref2","nextPlacement","positionLeft","positionTop","arrowOffsetLeft","arrowOffsetTop","topDelta","undefined","leftDelta","document","dir","_getContainerDimensio4","scrollWidth","nextLeft","_nextLeft","nextTop","positionClassName"],"sources":["/Users/peeranat/Desktop/Project/fontend/node_modules/rsuite/esm/Overlay/positionUtils.js"],"sourcesContent":["import maxBy from 'lodash/maxBy';\nimport minBy from 'lodash/minBy';\nimport kebabCase from 'lodash/kebabCase';\nimport ownerDocument from 'dom-lib/ownerDocument';\nimport getOffset from 'dom-lib/getOffset';\nimport scrollTop from 'dom-lib/scrollTop';\nimport scrollLeft from 'dom-lib/scrollLeft';\nimport _getPosition from 'dom-lib/getPosition';\nimport getStyle from 'dom-lib/getStyle';\nimport nodeName from 'dom-lib/nodeName';\nexport var AutoPlacement = {\n  left: 'Start',\n  right: 'End',\n  top: 'Start',\n  bottom: 'End'\n};\n\n/**\n * Get the external dimensions of the container\n * @param containerNode\n */\nfunction getContainerDimensions(containerNode) {\n  var width;\n  var height;\n  var scrollX;\n  var scrollY;\n\n  if (containerNode.tagName === 'BODY') {\n    width = window.innerWidth;\n    height = window.innerHeight;\n    scrollY = scrollTop(ownerDocument(containerNode).documentElement) || scrollTop(containerNode);\n    scrollX = scrollLeft(ownerDocument(containerNode).documentElement) || scrollLeft(containerNode);\n  } else {\n    var _ref = getOffset(containerNode);\n\n    width = _ref.width;\n    height = _ref.height;\n    scrollY = scrollTop(containerNode);\n    scrollX = scrollLeft(containerNode);\n  }\n\n  return {\n    width: width,\n    height: height,\n    scrollX: scrollX,\n    scrollY: scrollY\n  };\n}\n\nexport default (function (props) {\n  var placement = props.placement,\n      preventOverflow = props.preventOverflow,\n      padding = props.padding;\n\n  function getTopDelta(top, overlayHeight, container) {\n    if (!preventOverflow) {\n      return 0;\n    }\n\n    var containerDimensions = getContainerDimensions(container);\n    var containerHeight = containerDimensions.height,\n        scrollY = containerDimensions.scrollY;\n    var topEdgeOffset = top - padding - scrollY;\n    var bottomEdgeOffset = top + padding + overlayHeight - scrollY;\n\n    if (topEdgeOffset < 0) {\n      return -topEdgeOffset;\n    } else if (bottomEdgeOffset > containerHeight) {\n      return containerHeight - bottomEdgeOffset;\n    }\n\n    return 0;\n  }\n\n  function getLeftDelta(left, overlayWidth, container) {\n    if (!preventOverflow) {\n      return 0;\n    }\n\n    var containerDimensions = getContainerDimensions(container);\n    var scrollX = containerDimensions.scrollX,\n        containerWidth = containerDimensions.width;\n    var leftEdgeOffset = left - padding - scrollX;\n    var rightEdgeOffset = left + padding + overlayWidth - scrollX;\n\n    if (leftEdgeOffset < 0) {\n      return -leftEdgeOffset;\n    } else if (rightEdgeOffset > containerWidth) {\n      return containerWidth - rightEdgeOffset;\n    }\n\n    return 0;\n  }\n\n  function getPositionTop(container, overlayHeight, top) {\n    if (!preventOverflow) {\n      return top;\n    }\n\n    var _getContainerDimensio = getContainerDimensions(container),\n        scrollY = _getContainerDimensio.scrollY,\n        containerHeight = _getContainerDimensio.height; // 判断 overlay 底部是否溢出，设置 top\n\n\n    if (overlayHeight + top > containerHeight + scrollY) {\n      return containerHeight - overlayHeight + scrollY;\n    } // top 的最小值不能少于纵向滚动条 y 的值\n\n\n    return Math.max(scrollY, top);\n  }\n\n  function getPositionLeft(container, overlayWidth, left) {\n    if (!preventOverflow) {\n      return left;\n    }\n\n    var _getContainerDimensio2 = getContainerDimensions(container),\n        scrollX = _getContainerDimensio2.scrollX,\n        containerWidth = _getContainerDimensio2.width;\n\n    if (overlayWidth + left > containerWidth + scrollX) {\n      return containerWidth - overlayWidth + scrollX;\n    } // left 的最小值不能少于横向滚动条 x 的值\n\n\n    return Math.max(scrollX, left);\n  }\n\n  return {\n    getPosition: function getPosition(target, container) {\n      var offset = container.tagName === 'BODY' ? getOffset(target) : _getPosition(target, container, false);\n      return offset;\n    },\n    getCursorOffsetPosition: function getCursorOffsetPosition(target, container, cursorPosition) {\n      var left = cursorPosition.left,\n          top = cursorPosition.top,\n          clientLeft = cursorPosition.clientLeft,\n          clientTop = cursorPosition.clientTop;\n      var offset = {\n        left: left,\n        top: top,\n        width: 10,\n        height: 10\n      };\n\n      if (getStyle(target, 'position') === 'fixed') {\n        offset.left = clientLeft;\n        offset.top = clientTop;\n        return offset;\n      }\n\n      if (container.tagName === 'BODY') {\n        return offset;\n      }\n\n      var containerOffset = {\n        top: 0,\n        left: 0\n      };\n\n      if (nodeName(container) !== 'html') {\n        var nextParentOffset = getOffset(container);\n\n        if (nextParentOffset) {\n          containerOffset.top = nextParentOffset.top;\n          containerOffset.left = nextParentOffset.left;\n        }\n      }\n\n      containerOffset.top += parseInt(getStyle(container, 'borderTopWidth'), 10) - scrollTop(container) || 0;\n      containerOffset.left += parseInt(getStyle(container, 'borderLeftWidth'), 10) - scrollLeft(container) || 0;\n      offset.left = left - containerOffset.left;\n      offset.top = top - containerOffset.top;\n      return offset;\n    },\n    calcAutoPlacement: function calcAutoPlacement(targetOffset, container, overlay) {\n      var _getContainerDimensio3 = getContainerDimensions(container),\n          width = _getContainerDimensio3.width,\n          height = _getContainerDimensio3.height,\n          scrollX = _getContainerDimensio3.scrollX,\n          scrollY = _getContainerDimensio3.scrollY;\n\n      var left = targetOffset.left - scrollX - overlay.width;\n      var top = targetOffset.top - scrollY - overlay.height;\n      var right = width - targetOffset.left - targetOffset.width + scrollX - overlay.width;\n      var bottom = height - targetOffset.top - targetOffset.height + scrollY - overlay.height;\n      var horizontal = [{\n        key: 'left',\n        value: left\n      }, {\n        key: 'right',\n        value: right\n      }];\n      var vertical = [{\n        key: 'top',\n        value: top\n      }, {\n        key: 'bottom',\n        value: bottom\n      }];\n      var AV = 'autoVertical';\n      var AH = 'autoHorizontal';\n      var direction;\n      var align;\n\n      if (placement.indexOf(AV) !== -1) {\n        direction = maxBy(vertical, function (o) {\n          return o.value;\n        });\n        return placement === AV ? direction.key : \"\" + direction.key + placement.replace(AV, '');\n      } else if (placement.indexOf(AH) !== -1) {\n        direction = maxBy(horizontal, function (o) {\n          return o.value;\n        });\n        return placement === AH ? direction.key : \"\" + direction.key + placement.replace(AH, '');\n      }\n      /**\n       * Precedence Vertical\n       * [...vertical, ...horizontal]\n       */\n\n\n      direction = maxBy([].concat(vertical, horizontal), function (o) {\n        return o.value;\n      });\n\n      if (direction.key === 'left' || direction.key === 'right') {\n        align = minBy(vertical, function (o) {\n          return o.value;\n        });\n      } else {\n        align = minBy(horizontal, function (o) {\n          return o.value;\n        });\n      }\n\n      return \"\" + direction.key + AutoPlacement[align.key];\n    },\n    // Calculate the position of the overlay\n    calcOverlayPosition: function calcOverlayPosition(overlayNode, target, container, cursorPosition) {\n      var childOffset = cursorPosition ? this.getCursorOffsetPosition(target, container, cursorPosition) : this.getPosition(target, container);\n\n      var _ref2 = getOffset(overlayNode),\n          overlayHeight = _ref2.height,\n          overlayWidth = _ref2.width;\n\n      var top = childOffset.top,\n          left = childOffset.left;\n      var nextPlacement = placement;\n\n      if (placement && placement.indexOf('auto') >= 0) {\n        nextPlacement = this.calcAutoPlacement(childOffset, container, {\n          height: overlayHeight,\n          width: overlayWidth\n        });\n      }\n\n      var positionLeft;\n      var positionTop;\n      var arrowOffsetLeft;\n      var arrowOffsetTop;\n\n      if (nextPlacement === 'left' || nextPlacement === 'right') {\n        positionTop = childOffset.top + (childOffset.height - overlayHeight) / 2;\n        var topDelta = getTopDelta(positionTop, overlayHeight, container);\n        positionTop += topDelta;\n        arrowOffsetTop = 50 * (1 - 2 * topDelta / overlayHeight) + \"%\";\n        arrowOffsetLeft = undefined;\n      } else if (nextPlacement === 'top' || nextPlacement === 'bottom') {\n        positionLeft = left + (childOffset.width - overlayWidth) / 2;\n        var leftDelta = getLeftDelta(positionLeft, overlayWidth, container);\n        positionLeft += leftDelta;\n        arrowOffsetLeft = 50 * (1 - 2 * leftDelta / overlayWidth) + \"%\";\n        arrowOffsetTop = undefined;\n      }\n\n      if (nextPlacement === 'top' || nextPlacement === 'topStart' || nextPlacement === 'topEnd') {\n        positionTop = getPositionTop(container, overlayHeight, childOffset.top - overlayHeight);\n      }\n\n      if (nextPlacement === 'bottom' || nextPlacement === 'bottomStart' || nextPlacement === 'bottomEnd') {\n        positionTop = getPositionTop(container, overlayHeight, childOffset.top + childOffset.height);\n      }\n\n      if (nextPlacement === 'left' || nextPlacement === 'leftStart' || nextPlacement === 'leftEnd') {\n        positionLeft = getPositionLeft(container, overlayWidth, childOffset.left - overlayWidth);\n      }\n\n      if (nextPlacement === 'right' || nextPlacement === 'rightStart' || nextPlacement === 'rightEnd') {\n        positionLeft = getPositionLeft(container, overlayWidth, childOffset.left + childOffset.width);\n      }\n\n      if (document.dir === 'rtl' && (nextPlacement === 'left' || nextPlacement === 'leftStart' || nextPlacement === 'leftEnd' || nextPlacement === 'right' || nextPlacement === 'rightStart' || nextPlacement === 'rightEnd')) {\n        /**\n         * When laying out in rtl, if the width of the container\n         * is less than the width of the container scrolling,\n         * you need to recalculate the left value.\n         */\n        var _getContainerDimensio4 = getContainerDimensions(container),\n            containerWidth = _getContainerDimensio4.width;\n\n        if (container.scrollWidth > containerWidth) {\n          positionLeft = containerWidth + positionLeft - container.scrollWidth;\n        }\n      }\n\n      if (nextPlacement === 'topStart' || nextPlacement === 'bottomStart') {\n        if (document.dir === 'rtl') {\n          var nextLeft = left + (childOffset.width - overlayWidth);\n          positionLeft = nextLeft + getLeftDelta(nextLeft, overlayWidth, container);\n        } else {\n          positionLeft = left + getLeftDelta(left, overlayWidth, container);\n        }\n      }\n\n      if (nextPlacement === 'topEnd' || nextPlacement === 'bottomEnd') {\n        if (document.dir === 'rtl') {\n          positionLeft = left + getLeftDelta(left, overlayWidth, container);\n        } else {\n          var _nextLeft = left + (childOffset.width - overlayWidth);\n\n          positionLeft = _nextLeft + getLeftDelta(_nextLeft, overlayWidth, container);\n        }\n      }\n\n      if (nextPlacement === 'leftStart' || nextPlacement === 'rightStart') {\n        positionTop = top + getTopDelta(top, overlayHeight, container);\n      }\n\n      if (nextPlacement === 'leftEnd' || nextPlacement === 'rightEnd') {\n        var nextTop = top + (childOffset.height - overlayHeight);\n        positionTop = nextTop + getTopDelta(nextTop, overlayHeight, container);\n      }\n\n      return {\n        positionLeft: positionLeft,\n        positionTop: positionTop,\n        arrowOffsetLeft: arrowOffsetLeft,\n        arrowOffsetTop: arrowOffsetTop,\n        positionClassName: \"placement-\" + kebabCase(nextPlacement)\n      };\n    }\n  };\n});"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}