{"version":3,"file":"hash-it.min.js","sources":["../src/constants.ts","../src/arrayBuffer.ts","../src/stringify.ts","../src/index.ts","../src/hash.ts"],"sourcesContent":["type ElementOf<T> = T extends (infer E)[]\n  ? E\n  : T extends readonly (infer E)[]\n  ? E\n  : never;\n\ntype MappedFlag<Type extends readonly any[]> = {\n  [Key in ElementOf<Type>]: true;\n};\n\ntype MappedClass<Type extends readonly any[]> = {\n  [Key in ElementOf<Type>]: `[object ${Key}]`;\n};\n\ntype MappedReverseClass<Type extends readonly any[]> = {\n  [Key in ElementOf<Type> as `[object ${Key}]`]: Key;\n};\n\nconst getClassTypes = <\n  Classes extends readonly any[],\n  Reversed extends boolean,\n>(\n  classes: Classes,\n  reversed: Reversed,\n): Reversed extends true ? MappedReverseClass<Classes> : MappedClass<Classes> =>\n  classes.reduce((map, className: Classes[number]) => {\n    const toStringClassName = `[object ${className}]`;\n\n    if (reversed) {\n      map[toStringClassName] = className;\n    } else {\n      map[className] = toStringClassName;\n    }\n\n    return map;\n  }, {});\n\nconst getFlags = <Flags extends readonly any[]>(\n  flags: Flags,\n): MappedFlag<Flags> =>\n  flags.reduce((flag, item: Flags[number]) => {\n    flag[item] = true;\n\n    return flag;\n  }, {});\n\nconst OBJECT_CLASSES = [\n  // self tags\n  'Array',\n  'Arguments',\n\n  'Object',\n\n  // toString tags\n  'RegExp',\n  'Symbol',\n\n  // iterable tags\n  'Map',\n  'Set',\n\n  'Date',\n\n  'Error',\n\n  'Event',\n\n  // bailout tags\n  'Generator',\n  'Promise',\n  'WeakMap',\n  'WeakSet',\n\n  'DocumentFragment',\n\n  // typed array tags\n  'Float32Array',\n  'Float64Array',\n  'Int8Array',\n  'Int16Array',\n  'Int32Array',\n  'Uint8Array',\n  'Uint8ClampedArray',\n  'Uint16Array',\n  'Uint32Array',\n\n  'ArrayBuffer',\n\n  'DataView',\n\n  'DocumentFragment',\n\n  'Window',\n\n  // primitive classes, e.g. new String()\n  'String',\n  'Number',\n  'Boolean',\n  'Function',\n  'Undefined',\n  'GeneratorFunction',\n  'BigInt',\n  'Null',\n] as const;\n\nexport const OBJECT_CLASS_TYPE = getClassTypes(OBJECT_CLASSES, false);\nexport const OBJECT_CLASS = getClassTypes(OBJECT_CLASSES, true);\n\nexport const BAILOUT_TAGS = getFlags([\n  OBJECT_CLASS_TYPE.Generator,\n  OBJECT_CLASS_TYPE.Promise,\n  OBJECT_CLASS_TYPE.WeakMap,\n  OBJECT_CLASS_TYPE.WeakSet,\n]);\n\nexport const ITERABLE_TAGS = getFlags([\n  OBJECT_CLASS_TYPE.Map,\n  OBJECT_CLASS_TYPE.Set,\n]);\n\nexport const NORMALIZED_TAGS = getFlags([\n  OBJECT_CLASS_TYPE.Date,\n  OBJECT_CLASS_TYPE.RegExp,\n]);\n\nexport const PRIMITIVE_TAGS = getFlags([\n  'bigint',\n  'boolean',\n  'function',\n  'number',\n  'string',\n  'undefined',\n]);\n\nexport const SELF_TAGS = getFlags([\n  OBJECT_CLASS_TYPE.Arguments,\n  OBJECT_CLASS_TYPE.Array,\n]);\n\nexport const TO_STRING_TAGS = getFlags([\n  OBJECT_CLASS_TYPE.RegExp,\n  OBJECT_CLASS_TYPE.Symbol,\n]);\n\nexport const TYPED_ARRAY_TAGS = getFlags([\n  OBJECT_CLASS_TYPE.Float32Array,\n  OBJECT_CLASS_TYPE.Float64Array,\n  OBJECT_CLASS_TYPE.Int8Array,\n  OBJECT_CLASS_TYPE.Int16Array,\n  OBJECT_CLASS_TYPE.Int32Array,\n  OBJECT_CLASS_TYPE.Uint8Array,\n  OBJECT_CLASS_TYPE.Uint8ClampedArray,\n  OBJECT_CLASS_TYPE.Uint16Array,\n  OBJECT_CLASS_TYPE.Uint32Array,\n]);\n","const HAS_BUFFER_FROM_SUPPORT =\n  typeof Buffer !== 'undefined' && typeof Buffer.from === 'function';\nconst HAS_UINT16ARRAY_SUPPORT = typeof Uint16Array === 'function';\n\n/**\n * get the string value of the buffer passed based on a Buffer\n *\n * @param buffer the array buffer to convert\n * @returns the stringified buffer\n */\nexport function getStringifiedArrayBufferFallback(\n  buffer: ArrayBufferLike,\n): string {\n  return String.fromCharCode.apply(\n    null,\n    new Uint16Array(buffer) as unknown as number[],\n  );\n}\n\n/**\n * get the string value of the buffer passed based on a Uint16Array\n *\n * @param buffer the array buffer to convert\n * @returns the stringified buffer\n */\nexport function getStringifiedArrayBufferModern(\n  buffer: ArrayBufferLike,\n): string {\n  return Buffer.from(buffer).toString('utf8');\n}\n\n/**\n * return a placeholder when no arraybuffer support exists\n *\n * @returns the placeholder\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport function getStringifiedArrayBufferNoSupport(buffer: ArrayBufferLike) {\n  return '';\n}\n\n/**\n * @function getStringifiedArrayBuffer\n *\n * @description\n * get the string value of the buffer passed\n *\n * @param {ArrayBuffer} buffer the array buffer to convert\n * @returns {string} the stringified buffer\n */\nexport const getStringifiedArrayBuffer = (() => {\n  if (HAS_BUFFER_FROM_SUPPORT) {\n    return getStringifiedArrayBufferModern;\n  }\n\n  if (HAS_UINT16ARRAY_SUPPORT) {\n    return getStringifiedArrayBufferFallback;\n  }\n\n  return getStringifiedArrayBufferNoSupport;\n})();\n","import {\n  BAILOUT_TAGS,\n  ITERABLE_TAGS,\n  NORMALIZED_TAGS,\n  OBJECT_CLASS,\n  OBJECT_CLASS_TYPE,\n  PRIMITIVE_TAGS,\n  SELF_TAGS,\n  TO_STRING_TAGS,\n  TYPED_ARRAY_TAGS,\n} from './constants';\nimport { getStringifiedArrayBuffer } from './arrayBuffer';\n\ntype ObjectClass = keyof typeof OBJECT_CLASS;\n\nconst XML_ELEMENT_REGEXP = /\\[object ([HTML|SVG](.*)Element)\\]/;\n\nconst toString = Object.prototype.toString;\nconst keys = Object.keys;\n\n/**\n * get the event object sorted by its properties\n *\n * @param event the event to sort\n * @returns the event object with all properties sorted\n */\nfunction getSortedEvent(event: Event) {\n  return {\n    bubbles: event.bubbles,\n    cancelBubble: event.cancelBubble,\n    cancelable: event.cancelable,\n    composed: event.composed,\n    currentTarget: event.currentTarget,\n    defaultPrevented: event.defaultPrevented,\n    eventPhase: event.eventPhase,\n    isTrusted: event.isTrusted,\n    returnValue: event.returnValue,\n    target: event.target,\n    type: event.type,\n  };\n}\n\n/**\n * get the sort result based on the two values to compare\n *\n * @param first the first value to compare\n * @param second the second value to compare\n * @returns should the value be sorted\n */\nfunction shouldSort(first: string, second: string) {\n  return first > second;\n}\n\n/**\n * get the sort result based on the two pairs to compare\n *\n * @param firstPair the first pair to compare\n * @param secondPair the second pair to compare\n * @returns should the value be sorted\n */\nfunction shouldSortPair(\n  firstPair: [string, string],\n  secondPair: [string, string],\n) {\n  return firstPair[0] > secondPair[0];\n}\n\n/**\n * sort the array based on the fn passed\n *\n * @param array the array to sort\n * @param fn the sorting function\n * @returns the sorted array\n */\nfunction sort(array: any[], fn: (item: any, comparisonItem: any) => boolean) {\n  let subIndex;\n  let value;\n\n  for (let index = 0; index < array.length; ++index) {\n    value = array[index];\n\n    for (\n      subIndex = index - 1;\n      ~subIndex && fn(array[subIndex], value);\n      --subIndex\n    ) {\n      array[subIndex + 1] = array[subIndex];\n    }\n\n    array[subIndex + 1] = value;\n  }\n\n  return array;\n}\n\n/**\n * get the pairs in the map for stringification\n *\n * @param map the map to get the pairs for\n * @returns the sorted, stringified map\n */\nfunction getSortedMap(map: Map<any, any>, cache: any[], keys: string[]) {\n  const entries: string[] = [];\n\n  map.forEach((value: any, key: any) => {\n    entries.push([\n      stringify(key, cache, keys),\n      stringify(value, cache, keys),\n    ] as unknown as string);\n  });\n\n  sort(entries, shouldSortPair);\n\n  for (let index = 0, entry; index < entries.length; ++index) {\n    entry = entries[index];\n    entries[index] = `[${entry[0]},${entry[1]}]`;\n  }\n\n  return `Map|[${entries.join(',')}]`;\n}\n\n/**\n * get the values in the set for stringification\n *\n * @param set the set to get the values for\n * @returns the sorted, stringified set\n */\nfunction getSortedSet(set: Set<any>, cache: any[], keys: string[]) {\n  const entries: string[] = [];\n\n  set.forEach((value: any) => {\n    entries.push(stringify(value, cache, keys));\n  });\n\n  sort(entries, shouldSort);\n\n  return `Set|[${entries.join(',')}]`;\n}\n\n/**\n * get the object with the keys sorted\n *\n * @param object the object to sort\n * @returns the sorted object\n */\nfunction getSortedObject<UnsortedObject>(object: UnsortedObject) {\n  const objectKeys = sort(keys(object), shouldSort);\n  const newObject = {} as UnsortedObject;\n\n  let key: keyof UnsortedObject;\n\n  for (let index = 0; index < objectKeys.length; ++index) {\n    key = objectKeys[index];\n\n    newObject[key] = object[key];\n  }\n\n  return newObject;\n}\n\n/**\n * build a string based on all the fragment's children\n *\n * @param fragment the fragment to stringify\n * @returns the stringified fragment\n */\nfunction getStringifiedDocumentFragment(fragment: DocumentFragment) {\n  const children = fragment.children;\n  const innerHTML: string[] = [];\n\n  for (let index = 0; index < children.length; ++index) {\n    innerHTML.push(children[index].outerHTML);\n  }\n\n  return innerHTML.join(',');\n}\n\n/**\n * get the index after that of the value match in the array (faster than\n * native indexOf) to determine the cutoff index for the `splice()` call.\n *\n * @param array the array to get the index of the value at\n * @param value the value to match\n * @returns the index after the value match in the array\n */\nfunction getCutoffIndex(array: any[], value: any) {\n  for (let index = 0; index < array.length; ++index) {\n    if (array[index] === value) {\n      return index + 1;\n    }\n  }\n\n  return 0;\n}\n\n/**\n * get the value normalized for stringification\n *\n * @param value the value to normalize\n * @param sortedCache the cache of sorted objects\n * @param passedTag the previously-calculated tag\n * @returns the normalized value\n */\nfunction getNormalizedValue(\n  value: any,\n  cache?: any[],\n  keys?: string[],\n  passedTag?: ObjectClass,\n) {\n  if (!passedTag) {\n    const type = typeof value;\n\n    if (PRIMITIVE_TAGS[type as keyof typeof PRIMITIVE_TAGS]) {\n      return `${type}|${value}`;\n    }\n\n    if (value === null) {\n      return `${value}|${value}`;\n    }\n  }\n\n  const tag = passedTag || (toString.call(value) as ObjectClass);\n\n  if (SELF_TAGS[tag as keyof typeof SELF_TAGS]) {\n    return value;\n  }\n\n  if (tag === OBJECT_CLASS_TYPE.Object) {\n    return getSortedObject(value);\n  }\n\n  if (TO_STRING_TAGS[tag as keyof typeof TO_STRING_TAGS]) {\n    return `${OBJECT_CLASS[tag]}|${value.toString()}`;\n  }\n\n  if (ITERABLE_TAGS[tag as keyof typeof ITERABLE_TAGS]) {\n    return value instanceof Map\n      ? getSortedMap(value, cache as any[], keys as string[])\n      : getSortedSet(value, cache as any, keys as string[]);\n  }\n\n  if (tag === OBJECT_CLASS_TYPE.Date) {\n    return `${OBJECT_CLASS[tag]}|${value.getTime()}`;\n  }\n\n  if (tag === OBJECT_CLASS_TYPE.Error) {\n    return `${OBJECT_CLASS[tag]}|${value.stack}`;\n  }\n\n  if (tag === OBJECT_CLASS_TYPE.Event) {\n    return getSortedEvent(value);\n  }\n\n  if (BAILOUT_TAGS[tag as keyof typeof BAILOUT_TAGS]) {\n    return `${OBJECT_CLASS[tag]}|NOT_ENUMERABLE`;\n  }\n\n  if (XML_ELEMENT_REGEXP.test(tag)) {\n    return `${tag.slice(8, -1)}|${value.outerHTML}`;\n  }\n\n  if (tag === OBJECT_CLASS_TYPE.DocumentFragment) {\n    return `${OBJECT_CLASS[tag]}|${getStringifiedDocumentFragment(value)}`;\n  }\n\n  if (TYPED_ARRAY_TAGS[tag as keyof typeof TYPED_ARRAY_TAGS]) {\n    return `${OBJECT_CLASS[tag]}|${value.join(',')}`;\n  }\n\n  if (tag === OBJECT_CLASS_TYPE.ArrayBuffer) {\n    return `${OBJECT_CLASS[tag]}|${getStringifiedArrayBuffer(value)}`;\n  }\n\n  if (tag === OBJECT_CLASS_TYPE.DataView) {\n    return `${OBJECT_CLASS[tag]}|${getStringifiedArrayBuffer(value.buffer)}`;\n  }\n\n  return value;\n}\n\n/**\n * create the replacer function used for stringification\n *\n * @param sortedCache the cache to use for sorting objects\n * @returns function getting the normalized value\n */\nfunction createReplacer(cache: any[] = [], keys: string[] = []) {\n  return function (this: any, key: string, value: any) {\n    if (typeof value === 'object') {\n      if (cache.length) {\n        const thisCutoff = getCutoffIndex(cache, this);\n\n        if (thisCutoff === 0) {\n          cache.push(this);\n        } else {\n          cache.splice(thisCutoff);\n          keys.splice(thisCutoff);\n        }\n\n        keys.push(key);\n\n        const valueCutoff = getCutoffIndex(cache, value);\n\n        if (valueCutoff !== 0) {\n          return `[~${keys.slice(0, valueCutoff).join('.') || '.'}]`;\n        }\n\n        cache.push(value);\n      } else {\n        cache[0] = value;\n        keys[0] = key;\n      }\n    }\n\n    if (key && this[key] instanceof Date) {\n      return getNormalizedValue(this[key], cache, keys, OBJECT_CLASS_TYPE.Date);\n    }\n\n    return getNormalizedValue(value, cache, keys);\n  };\n}\n\n/**\n * stringify the value based on the options passed\n *\n * @param value the value to stringify\n * @returns the stringified value\n */\nfunction stringify(value: any, cache?: any[], keys?: string[]): string {\n  if (!value || typeof value !== 'object') {\n    return getNormalizedValue(value, cache, keys);\n  }\n\n  const tag = toString.call(value) as ObjectClass;\n\n  if (NORMALIZED_TAGS[tag as keyof typeof NORMALIZED_TAGS]) {\n    return getNormalizedValue(value, cache, keys, tag);\n  }\n\n  return JSON.stringify(value, createReplacer(cache, keys));\n}\n\nexport default stringify;\n","import getUniqueIntegerFromString from './hash';\nimport stringify from './stringify';\n\n/**\n * hash the value passed to a unique, consistent hash value\n *\n * @param value the value to hash\n * @returns the object hash\n */\nfunction hash(value: any) {\n  return getUniqueIntegerFromString(stringify(value));\n}\n\nfunction is(value: any, otherValue: any) {\n  return hash(value) === hash(otherValue);\n}\n\nfunction isAll(value: any, ...otherValues: any[]) {\n  for (let index = 0; index < otherValues.length; ++index) {\n    if (!is(value, otherValues[index])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction isAny(value: any, ...otherValues: any[]) {\n  for (let index = 0; index < otherValues.length; ++index) {\n    if (is(value, otherValues[index])) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction isNot(value: any, otherValue: any) {\n  return hash(value) !== hash(otherValue);\n}\n\nis.all = isAll;\nis.any = isAny;\nis.not = isNot;\n\nhash.is = is;\n\nexport default hash;\n","/**\n * based on string passed, get the integer hash value\n * through bitwise operation (based on spinoff of dbj2\n * with enhancements for reduced collisions)\n *\n * @param string the string to get the hash value for\n * @returns the hash value\n */\nfunction getUniqueIntegerFromString(string: string) {\n  let index = string.length;\n  let hashA = 5381;\n  let hashB = 52711;\n  let charCode;\n\n  while (index--) {\n    charCode = string.charCodeAt(index);\n\n    hashA = (hashA * 33) ^ charCode;\n    hashB = (hashB * 33) ^ charCode;\n  }\n\n  return (hashA >>> 0) * 4096 + (hashB >>> 0);\n}\n\nexport default getUniqueIntegerFromString;\n"],"names":["getClassTypes","classes","reversed","reduce","map","className","toStringClassName","getFlags","flags","flag","item","OBJECT_CLASSES","OBJECT_CLASS_TYPE","OBJECT_CLASS","BAILOUT_TAGS","Generator","Promise","WeakMap","WeakSet","ITERABLE_TAGS","Map","Set","NORMALIZED_TAGS","Date","RegExp","PRIMITIVE_TAGS","SELF_TAGS","Arguments","Array","TO_STRING_TAGS","Symbol","TYPED_ARRAY_TAGS","Float32Array","Float64Array","Int8Array","Int16Array","Int32Array","Uint8Array","Uint8ClampedArray","Uint16Array","Uint32Array","HAS_BUFFER_FROM_SUPPORT","Buffer","from","HAS_UINT16ARRAY_SUPPORT","getStringifiedArrayBufferFallback","buffer","String","fromCharCode","apply","getStringifiedArrayBufferModern","toString","getStringifiedArrayBufferNoSupport","getStringifiedArrayBuffer","XML_ELEMENT_REGEXP","Object","prototype","keys","shouldSort","first","second","shouldSortPair","firstPair","secondPair","sort","array","fn","subIndex","value","index","length","getSortedObject","object","key","objectKeys","newObject","getCutoffIndex","getNormalizedValue","cache","passedTag","type","event","tag","call","entries","forEach","push","stringify","entry","join","getSortedMap","set","getSortedSet","getTime","Error","stack","Event","bubbles","cancelBubble","cancelable","composed","currentTarget","defaultPrevented","eventPhase","isTrusted","returnValue","target","test","slice","outerHTML","DocumentFragment","fragment","children","innerHTML","getStringifiedDocumentFragment","ArrayBuffer","DataView","JSON","thisCutoff","this","splice","valueCutoff","createReplacer","hash","string","charCode","hashA","hashB","charCodeAt","getUniqueIntegerFromString","is","otherValue","all","any","not"],"mappings":"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"}